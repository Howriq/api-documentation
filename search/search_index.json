{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"#readmemd","text":"","title":"../../README.md"},{"location":"v4/commands/create-admin-account/","text":"Creating admin accounts in DotKernel API Usage Run the following command in your application’s root directory: php ./bin/cli.php admin:create -i {IDENTITY} -p {PASSWORD} -f {FIRST_NAME} -l {LAST_NAME} OR php ./bin/cli.php admin:create --identity {IDENTITY} --password {PASSWORD} --firstName {FIRST_NAME} --lastName {LAST_NAME} after replacing: {IDENTITY} with a valid username OR email address {PASSWORD} with a valid password {FIRST_NAME} and {LAST_NAME} with valid names NOTE: if the specified fields contain special characters, make sure you surround them with double quote signs this method does not allow specifying an admin role – newly created accounts will have role of admin If the submitted data is valid, the outputted response is: Admin account has been created. The new admin account is ready to use. You can get more help with this command by running: php ./bin/cli.php help admin:create","title":"Create admin account"},{"location":"v4/commands/create-admin-account/#creating-admin-accounts-in-dotkernel-api","text":"","title":"Creating admin accounts in DotKernel API"},{"location":"v4/commands/create-admin-account/#usage","text":"Run the following command in your application’s root directory: php ./bin/cli.php admin:create -i {IDENTITY} -p {PASSWORD} -f {FIRST_NAME} -l {LAST_NAME} OR php ./bin/cli.php admin:create --identity {IDENTITY} --password {PASSWORD} --firstName {FIRST_NAME} --lastName {LAST_NAME} after replacing: {IDENTITY} with a valid username OR email address {PASSWORD} with a valid password {FIRST_NAME} and {LAST_NAME} with valid names NOTE: if the specified fields contain special characters, make sure you surround them with double quote signs this method does not allow specifying an admin role – newly created accounts will have role of admin If the submitted data is valid, the outputted response is: Admin account has been created. The new admin account is ready to use. You can get more help with this command by running: php ./bin/cli.php help admin:create","title":"Usage"},{"location":"v4/commands/display-available-endpoints/","text":"Displaying DotKernel API endpoints using dot-cli Usage Run the following command in your application’s root directory: php ./bin/cli.php route:list The command runs through all routes and extracts endpoint information in realtime. The output should be similar to the following: +--------+---------------------------------+--------------------------------+ | Method | Name | Path | +--------+---------------------------------+--------------------------------+ | POST | account.activate.request | /account/activate | | PATCH | account.activate | /account/activate/{hash} | | PATCH | account.modify-password | /account/reset-password/{hash} | | POST | account.recover-identity | /account/recover-identity | | POST | account.register | /account/register | | POST | account.reset-password.request | /account/reset-password | | GET | account.reset-password.validate | /account/reset-password/{hash} | | POST | admin.create | /admin | | DELETE | admin.delete | /admin/{uuid} | | GET | admin.list | /admin | | PATCH | admin.my-account.update | /admin/my-account | | GET | admin.my-account.view | /admin/my-account | | GET | admin.role.list | /admin/role | | GET | admin.role.view | /admin/role/{uuid} | | PATCH | admin.update | /admin/{uuid} | | GET | admin.view | /admin/{uuid} | | POST | error.report | /error-report | | GET | home | / | | POST | security.generate-token | /security/generate-token | | POST | security.refresh-token | /security/refresh-token | | POST | user.activate | /user/{uuid}/activate | | POST | user.avatar.create | /user/{uuid}/avatar | | DELETE | user.avatar.delete | /user/{uuid}/avatar | | GET | user.avatar.view | /user/{uuid}/avatar | | POST | user.create | /user | | DELETE | user.delete | /user/{uuid} | | GET | user.list | /user | | DELETE | user.my-account.delete | /user/my-account | | PATCH | user.my-account.update | /user/my-account | | GET | user.my-account.view | /user/my-account | | POST | user.my-avatar.create | /user/my-avatar | | DELETE | user.my-avatar.delete | /user/my-avatar | | GET | user.my-avatar.view | /user/my-avatar | | GET | user.role.list | /user/role | | GET | user.role.view | /user/role/{uuid} | | PATCH | user.update | /user/{uuid} | | GET | user.view | /user/{uuid} | +--------+---------------------------------+--------------------------------+ Filtering results The following filters can be applied when displaying the routes list: Filter routes by name, using: -i|--name[=NAME] Filter routes by path, using: -p|--path[=PATH] Filter routes by method, using: -m|--method[=METHOD] The filters are case-insensitive and can be combined. Get more help by running this command: php ./bin/cli.php route:list --help","title":"Display available endpoints"},{"location":"v4/commands/display-available-endpoints/#displaying-dotkernel-api-endpoints-using-dot-cli","text":"","title":"Displaying DotKernel API endpoints using dot-cli"},{"location":"v4/commands/display-available-endpoints/#usage","text":"Run the following command in your application’s root directory: php ./bin/cli.php route:list The command runs through all routes and extracts endpoint information in realtime. The output should be similar to the following: +--------+---------------------------------+--------------------------------+ | Method | Name | Path | +--------+---------------------------------+--------------------------------+ | POST | account.activate.request | /account/activate | | PATCH | account.activate | /account/activate/{hash} | | PATCH | account.modify-password | /account/reset-password/{hash} | | POST | account.recover-identity | /account/recover-identity | | POST | account.register | /account/register | | POST | account.reset-password.request | /account/reset-password | | GET | account.reset-password.validate | /account/reset-password/{hash} | | POST | admin.create | /admin | | DELETE | admin.delete | /admin/{uuid} | | GET | admin.list | /admin | | PATCH | admin.my-account.update | /admin/my-account | | GET | admin.my-account.view | /admin/my-account | | GET | admin.role.list | /admin/role | | GET | admin.role.view | /admin/role/{uuid} | | PATCH | admin.update | /admin/{uuid} | | GET | admin.view | /admin/{uuid} | | POST | error.report | /error-report | | GET | home | / | | POST | security.generate-token | /security/generate-token | | POST | security.refresh-token | /security/refresh-token | | POST | user.activate | /user/{uuid}/activate | | POST | user.avatar.create | /user/{uuid}/avatar | | DELETE | user.avatar.delete | /user/{uuid}/avatar | | GET | user.avatar.view | /user/{uuid}/avatar | | POST | user.create | /user | | DELETE | user.delete | /user/{uuid} | | GET | user.list | /user | | DELETE | user.my-account.delete | /user/my-account | | PATCH | user.my-account.update | /user/my-account | | GET | user.my-account.view | /user/my-account | | POST | user.my-avatar.create | /user/my-avatar | | DELETE | user.my-avatar.delete | /user/my-avatar | | GET | user.my-avatar.view | /user/my-avatar | | GET | user.role.list | /user/role | | GET | user.role.view | /user/role/{uuid} | | PATCH | user.update | /user/{uuid} | | GET | user.view | /user/{uuid} | +--------+---------------------------------+--------------------------------+","title":"Usage"},{"location":"v4/commands/display-available-endpoints/#filtering-results","text":"The following filters can be applied when displaying the routes list: Filter routes by name, using: -i|--name[=NAME] Filter routes by path, using: -p|--path[=PATH] Filter routes by method, using: -m|--method[=METHOD] The filters are case-insensitive and can be combined. Get more help by running this command: php ./bin/cli.php route:list --help","title":"Filtering results"},{"location":"v4/commands/generate-database-migrations/","text":"Generate a database migration without dropping custom tables Usage Run the following command in your application’s root directory: vendor/bin/doctrine-migrations diff If you have mapping modifications, this will create a new migration file under data/doctrine/migrations/ directory. Opening the migration file, you will notice that it contains some queries that will drop your oauth_* tables because they are unmapped (there is no doctrine entity describing them). You should delete your latest migration with the DROP queries in it as we will create another one, without the DROP queries in it. In order to avoid dropping these tables, you need to add a parameter called filter-expression . The command to be executed without dropping these tables looks like this: On Windows (use double quotes): vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!oauth_)/\" On Linux/macOS (use single quotes): vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' Filtering multiple unmapped table patterns If your database contains multiple unmapped table groups, then the pattern in filter-expression should hold all table prefixes concatenated by pipe character ( | ). For example, if you need to filter tables prefixed with foo_ and bar_ , then the command should look like this: On Windows: vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!foo_|bar_)/\" On Linux/macOS: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!foo_|bar_)/' Troubleshooting On Windows, running the command in PowerShell might still add the DROP TABLE oauth_* queries to the migration file. This happens because for PowerShell the caret ( ^ ) is a special character, so it gets dropped ( \"/^(?!oauth_)/\" becomes \"/(?!oauth_)/\" when it reaches your command). Escaping it will not help either. In this case, we recommend running the command: directly from your IDE using Linux shell from the Command Prompt Help You can get more help with this command by running: vendor/bin/doctrine-migrations help diff","title":"Generate database migrations"},{"location":"v4/commands/generate-database-migrations/#generate-a-database-migration-without-dropping-custom-tables","text":"","title":"Generate a database migration without dropping custom tables"},{"location":"v4/commands/generate-database-migrations/#usage","text":"Run the following command in your application’s root directory: vendor/bin/doctrine-migrations diff If you have mapping modifications, this will create a new migration file under data/doctrine/migrations/ directory. Opening the migration file, you will notice that it contains some queries that will drop your oauth_* tables because they are unmapped (there is no doctrine entity describing them). You should delete your latest migration with the DROP queries in it as we will create another one, without the DROP queries in it. In order to avoid dropping these tables, you need to add a parameter called filter-expression . The command to be executed without dropping these tables looks like this: On Windows (use double quotes): vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!oauth_)/\" On Linux/macOS (use single quotes): vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/'","title":"Usage"},{"location":"v4/commands/generate-database-migrations/#filtering-multiple-unmapped-table-patterns","text":"If your database contains multiple unmapped table groups, then the pattern in filter-expression should hold all table prefixes concatenated by pipe character ( | ). For example, if you need to filter tables prefixed with foo_ and bar_ , then the command should look like this: On Windows: vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!foo_|bar_)/\" On Linux/macOS: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!foo_|bar_)/'","title":"Filtering multiple unmapped table patterns"},{"location":"v4/commands/generate-database-migrations/#troubleshooting","text":"On Windows, running the command in PowerShell might still add the DROP TABLE oauth_* queries to the migration file. This happens because for PowerShell the caret ( ^ ) is a special character, so it gets dropped ( \"/^(?!oauth_)/\" becomes \"/(?!oauth_)/\" when it reaches your command). Escaping it will not help either. In this case, we recommend running the command: directly from your IDE using Linux shell from the Command Prompt","title":"Troubleshooting"},{"location":"v4/commands/generate-database-migrations/#help","text":"You can get more help with this command by running: vendor/bin/doctrine-migrations help diff","title":"Help"},{"location":"v4/commands/generate-tokens/","text":"Generating tokens in DotKernel API This is a multipurpose command that allows creating tokens required by different parts of the API. Usage Go to your application's root directory. Run the token generator command by executing the following command: php ./bin/cli.php token:generate &lt;type&gt; Where &lt;type&gt; is one of the following: error-reporting If you need help using the command, execute the following command: php ./bin/cli.php token:generate --help Generate error reporting token You can generate an error reporting token by executing the following command: php ./bin/cli.php token:generate error-reporting The output should look similar to this: Error reporting token: 0123456789abcdef0123456789abcdef01234567 Copy the generated token. Open config/autoload/error-handling.global.php and paste the copied token as shown below: return [ ... ErrorReportServiceInterface::class =&gt; [ ... 'tokens' =&gt; [ '0123456789abcdef0123456789abcdef01234567', ], ... ] ] Save and close config/autoload/error-handling.global.php . Note : If your application is NOT in development mode, make sure you clear your config cache by executing: php ./bin/clear-config-cache.php","title":"Generate tokens"},{"location":"v4/commands/generate-tokens/#generating-tokens-in-dotkernel-api","text":"This is a multipurpose command that allows creating tokens required by different parts of the API.","title":"Generating tokens in DotKernel API"},{"location":"v4/commands/generate-tokens/#usage","text":"Go to your application's root directory. Run the token generator command by executing the following command: php ./bin/cli.php token:generate &lt;type&gt; Where &lt;type&gt; is one of the following: error-reporting If you need help using the command, execute the following command: php ./bin/cli.php token:generate --help","title":"Usage"},{"location":"v4/core-features/authentication/","text":"Authentication Authentication is the process by which an identity is presented to the application. It ensures that the entity making the request has the proper credentials to access the API. DotKernel API identities are delivered to the application from the client through the Authorization request. If it is present, the application tries to find and assign the identity to the application. If it is not presented, DotKernel API assigns a default guest identity, represented by an instance of the class Mezzio\\Authentication\\UserInterface . Configuration Authentication in DotKernel API is built around the mezzio/mezzio-authentication-oauth2 component and is already configured out of the box. But if you want to dig more, the configuration is stored in config/autoload/local.php under the authentication key. You can check the mezzio/mezzio-authentication-oauth2 configuration part for more info. How it works DotKernels API authentication system can be used for SPAs (single-page applications), mobile applications, and simple, token-based APIs. It allows each user of your application to generate API tokens for their accounts. The authentication happens through the middleware in the Api\\App\\Middleware\\AuthenticationMiddleware . Database When you install DotKernel API for the first time, you need to run the migrations and seeders. All the tables required for authentication are automatically created and populated. In DotKernel API, authenticated users come from either the admin or the user table. We choose to keep the admin table separated from the users to prevent users of the application from accessing sensitive data, which only the administrators of the application should access. The oauth_clients table is pre-populated with the default admin and frontend clients with the same password as their names ( we recommend you change the default passwords ). As you guessed each client serves to authenticate admin or user . Another table that is pre-populated is the oauth_scopes table, with the api scope. Issuing API Tokens Token generation in DotKernel API is done using the password grand_type scenario, which in this case allows authentication to an API using the user's credentials (generally a username and password). The client sends a POST request to the /security/generate-token with the following parameters: grant_type = password. client_id = column name from the oauth_clients table client_secret = column secret from the oauth_clients table scope = column scope from the oauth_scopes table username = column identity from table admin / user password = column password from table admin / user POST /security/generate-token HTTP/1.1 Accept: application/json Content-Type: application/json { \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"test@dotkernel.com\", \"password\": \"dotkernel\" } The server responds with a JSON as follows: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...\", \"refresh_token\": \"def5020087199939a49d0f2f818...\" } Next time when you make a request to the server to an authenticated endpoint, the client should use the Authorization header request. GET /users/1 HTTP/1.1 Accept: application/json Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9... Refreshing tokens DotKernel API can refresh the access token, based on the expired access token's refresh_token . The clients need to send a POST request to the /security/refresh-token with the following request POST /security/refresh-token HTTP/1.1 Accept: application/json Content-Type: application/json { \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\" : \"def5020087199939a49d0f2f818...\" } The server responds with a JSON as follows: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...\", \"refresh_token\": \"def5020087199939a49d0f2f818...\" }","title":"Authentication"},{"location":"v4/core-features/authentication/#authentication","text":"Authentication is the process by which an identity is presented to the application. It ensures that the entity making the request has the proper credentials to access the API. DotKernel API identities are delivered to the application from the client through the Authorization request. If it is present, the application tries to find and assign the identity to the application. If it is not presented, DotKernel API assigns a default guest identity, represented by an instance of the class Mezzio\\Authentication\\UserInterface .","title":"Authentication"},{"location":"v4/core-features/authentication/#configuration","text":"Authentication in DotKernel API is built around the mezzio/mezzio-authentication-oauth2 component and is already configured out of the box. But if you want to dig more, the configuration is stored in config/autoload/local.php under the authentication key. You can check the mezzio/mezzio-authentication-oauth2 configuration part for more info.","title":"Configuration"},{"location":"v4/core-features/authentication/#how-it-works","text":"DotKernels API authentication system can be used for SPAs (single-page applications), mobile applications, and simple, token-based APIs. It allows each user of your application to generate API tokens for their accounts. The authentication happens through the middleware in the Api\\App\\Middleware\\AuthenticationMiddleware .","title":"How it works"},{"location":"v4/core-features/authentication/#database","text":"When you install DotKernel API for the first time, you need to run the migrations and seeders. All the tables required for authentication are automatically created and populated. In DotKernel API, authenticated users come from either the admin or the user table. We choose to keep the admin table separated from the users to prevent users of the application from accessing sensitive data, which only the administrators of the application should access. The oauth_clients table is pre-populated with the default admin and frontend clients with the same password as their names ( we recommend you change the default passwords ). As you guessed each client serves to authenticate admin or user . Another table that is pre-populated is the oauth_scopes table, with the api scope.","title":"Database"},{"location":"v4/core-features/authorization/","text":"Authorization Authorization is the process by which a system takes a validated identity and checks if that identity has access to a given resource. DotKernel API 's implementation of authorization uses Mezzio\\Authorization\\Rbac\\LaminasRbac as a model of Role-Based Access Control (RBAC). How it works In DotKernel API each authenticatable entity (admin/user) comes with their roles table where you can define roles for each entity. RBAC comes in to ensure that each entity has the appropriate role and permission to access a resource. The authorization happens through the Api\\App\\Middleware\\AuthorizationMiddleware middleware. Configuration DotKernel API makes use of mezzio-authorization-rbac and includes the full configuration. The configuration file for the role and permission definitions is config/autoload/authorization.global.php . 'mezzio-authorization-rbac' =&gt; [ 'roles' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ AdminRole::ROLE_SUPERUSER, ], UserRole::ROLE_GUEST =&gt; [ UserRole::ROLE_USER, ], ], 'permissions' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ 'other.routes' 'admin.list', 'home' ], UserRole::ROLE_USER =&gt; [ 'other.routes', 'user.my-account.update', 'user.my-account.view', ], UserRole::ROLE_GUEST =&gt; [ 'other.routes', 'security.refresh-token', 'error.report', 'home', ], ], ], See mezzio-authorization-rbac for more information. Usage Based on the configuration file above, we have 2 admins roles ( superuser , admin ) and 2 users roles ( user , guest ). Roles inherit the permissions from their parents: superuser has no parent admin has superuser as a parent which means superuser also has admin permissions user has no parent guest has user as a parent which means user also has guest permissions For each role we defined an array of permissions. A permission in DotKernel API is basically a route name. As you can see, the superuser does not have its own permissions, because it gains all the permissions from admin , no need to define explicit permissions. The user role, gains all the permission from guest so no need to define that user can access home route, but guest cannot access user-specific routes.","title":"Authorization"},{"location":"v4/core-features/authorization/#authorization","text":"Authorization is the process by which a system takes a validated identity and checks if that identity has access to a given resource. DotKernel API 's implementation of authorization uses Mezzio\\Authorization\\Rbac\\LaminasRbac as a model of Role-Based Access Control (RBAC).","title":"Authorization"},{"location":"v4/core-features/authorization/#how-it-works","text":"In DotKernel API each authenticatable entity (admin/user) comes with their roles table where you can define roles for each entity. RBAC comes in to ensure that each entity has the appropriate role and permission to access a resource. The authorization happens through the Api\\App\\Middleware\\AuthorizationMiddleware middleware.","title":"How it works"},{"location":"v4/core-features/authorization/#configuration","text":"DotKernel API makes use of mezzio-authorization-rbac and includes the full configuration. The configuration file for the role and permission definitions is config/autoload/authorization.global.php . 'mezzio-authorization-rbac' =&gt; [ 'roles' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ AdminRole::ROLE_SUPERUSER, ], UserRole::ROLE_GUEST =&gt; [ UserRole::ROLE_USER, ], ], 'permissions' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ 'other.routes' 'admin.list', 'home' ], UserRole::ROLE_USER =&gt; [ 'other.routes', 'user.my-account.update', 'user.my-account.view', ], UserRole::ROLE_GUEST =&gt; [ 'other.routes', 'security.refresh-token', 'error.report', 'home', ], ], ], See mezzio-authorization-rbac for more information.","title":"Configuration"},{"location":"v4/core-features/authorization/#usage","text":"Based on the configuration file above, we have 2 admins roles ( superuser , admin ) and 2 users roles ( user , guest ). Roles inherit the permissions from their parents: superuser has no parent admin has superuser as a parent which means superuser also has admin permissions user has no parent guest has user as a parent which means user also has guest permissions For each role we defined an array of permissions. A permission in DotKernel API is basically a route name. As you can see, the superuser does not have its own permissions, because it gains all the permissions from admin , no need to define explicit permissions. The user role, gains all the permission from guest so no need to define that user can access home route, but guest cannot access user-specific routes.","title":"Usage"},{"location":"v4/core-features/content-validation/","text":"Content Negotiation Content Negotiation is performed by an application in order : To match the requested representation as specified by the client via the Accept header with a representation the application can deliver. To determine the Content-Type of incoming data and deserialize it so the application can utilize it. Essentially, content negotiation is the client telling the server what it is sending and what it wants in return, and the server determining if it can do what the client requests. Content negotiation validation in DotKernel API happens through middleware, and it ensures that the incoming request and the outgoing response conform to the content types specified in the config file for all routes or for a specific route. It performs validation on the Accept and Content-Type headers of the request and response and returning appropriate errors responses when necessary. Configuration In DotKernel API the configuration file for content negotiation is held in config/autoload/content-negotiation.global.php and the array looks like this: return [ 'content-negotiation' =&gt; [ 'default' =&gt; [ 'Accept' =&gt; [ 'application/json', 'application/hal+json', ], 'Content-Type' =&gt; [ 'application/json', 'application/hal+json', ], ], 'your.route.name' =&gt; [ 'Accept' =&gt; [], 'Content-Type' =&gt; [], ], ], ]; Except the default key, all your keys must match the route name, for example in DotKernel API we have the route to list all admins, which name is admin.list . If you did not specify a route name to configure your specifications about content negotiation, the default one will be in place. The default key is mandatory . Every route configuration must come with Accept and Content-Type keys, basically this will be the keys that the request headers will be validated against. Accept Negotiation This specifies that your server can return that representation, or at least one of the representation sent by the client. GET /admin HTTP/1.1 Accept: application/json This request indicates the client wants application/json in return. Now the server, through the config file will try to validate if that representation can be returned, basically if application/json is presented in the Accept key. If the representation cannot be returned, a status code 406 - Not Acceptable will be returned. If the representation can be returned, the server should report the media type through Content-Type header of the response. Due to how these validations are made, for a json media type, the server can return a more generic media type, for example, if the clients send Accept: application/vnd.api+json and you configured your Accept key as application/json the representation will still be returned as json . If the Accept header of the request contains */* it means that whatever the server can return it is OK, so it can return anything. Content-Type Negotiation The second aspect of content negotiation is the Content-Type header and determine the server can deserialize the data. POST /admin/1 HTTP/1.1 Accept: application/json Content-Type: application/json { \"foo\": \"bar\" } The server will try to validate the Content-Type header against your configured Content-Type key from the config file, and if the format is not supported, a status code 415 - Unsupported Media Type will be returned. For example, if you have a route that needs a file to be uploaded , normally you will configure the Content-Type of that route to be multipart/form-data . The above request will fail as the client send application/json as Content-Type . If the request does not contain \"Content-Type\" header, that means that the server will try to deserialize the data as it can. The Request &lt;-&gt; Response validation In addition to the validation described above, a third one is happening and is the last one: the server will check if the request Accept header can really be returned by the response. Through the way DotKernel API is returning a response in handler, a content type is always set. This cannot be the case in any custom response but in any case the server will check what Content-Type the response is returning and will try to validate that against the Accept header of the request. If the validation fails, a status code 406 - Not Acceptable will be returned.","title":"Content Validation"},{"location":"v4/core-features/content-validation/#content-negotiation","text":"Content Negotiation is performed by an application in order : To match the requested representation as specified by the client via the Accept header with a representation the application can deliver. To determine the Content-Type of incoming data and deserialize it so the application can utilize it. Essentially, content negotiation is the client telling the server what it is sending and what it wants in return, and the server determining if it can do what the client requests. Content negotiation validation in DotKernel API happens through middleware, and it ensures that the incoming request and the outgoing response conform to the content types specified in the config file for all routes or for a specific route. It performs validation on the Accept and Content-Type headers of the request and response and returning appropriate errors responses when necessary.","title":"Content Negotiation"},{"location":"v4/core-features/content-validation/#configuration","text":"In DotKernel API the configuration file for content negotiation is held in config/autoload/content-negotiation.global.php and the array looks like this: return [ 'content-negotiation' =&gt; [ 'default' =&gt; [ 'Accept' =&gt; [ 'application/json', 'application/hal+json', ], 'Content-Type' =&gt; [ 'application/json', 'application/hal+json', ], ], 'your.route.name' =&gt; [ 'Accept' =&gt; [], 'Content-Type' =&gt; [], ], ], ]; Except the default key, all your keys must match the route name, for example in DotKernel API we have the route to list all admins, which name is admin.list . If you did not specify a route name to configure your specifications about content negotiation, the default one will be in place. The default key is mandatory . Every route configuration must come with Accept and Content-Type keys, basically this will be the keys that the request headers will be validated against.","title":"Configuration"},{"location":"v4/core-features/content-validation/#accept-negotiation","text":"This specifies that your server can return that representation, or at least one of the representation sent by the client. GET /admin HTTP/1.1 Accept: application/json This request indicates the client wants application/json in return. Now the server, through the config file will try to validate if that representation can be returned, basically if application/json is presented in the Accept key. If the representation cannot be returned, a status code 406 - Not Acceptable will be returned. If the representation can be returned, the server should report the media type through Content-Type header of the response. Due to how these validations are made, for a json media type, the server can return a more generic media type, for example, if the clients send Accept: application/vnd.api+json and you configured your Accept key as application/json the representation will still be returned as json . If the Accept header of the request contains */* it means that whatever the server can return it is OK, so it can return anything.","title":"Accept Negotiation"},{"location":"v4/core-features/content-validation/#content-type-negotiation","text":"The second aspect of content negotiation is the Content-Type header and determine the server can deserialize the data. POST /admin/1 HTTP/1.1 Accept: application/json Content-Type: application/json { \"foo\": \"bar\" } The server will try to validate the Content-Type header against your configured Content-Type key from the config file, and if the format is not supported, a status code 415 - Unsupported Media Type will be returned. For example, if you have a route that needs a file to be uploaded , normally you will configure the Content-Type of that route to be multipart/form-data . The above request will fail as the client send application/json as Content-Type . If the request does not contain \"Content-Type\" header, that means that the server will try to deserialize the data as it can.","title":"Content-Type Negotiation"},{"location":"v4/core-features/content-validation/#the-request-response-validation","text":"In addition to the validation described above, a third one is happening and is the last one: the server will check if the request Accept header can really be returned by the response. Through the way DotKernel API is returning a response in handler, a content type is always set. This cannot be the case in any custom response but in any case the server will check what Content-Type the response is returning and will try to validate that against the Accept header of the request. If the validation fails, a status code 406 - Not Acceptable will be returned.","title":"The Request &lt;-&gt; Response validation"},{"location":"v4/core-features/cors/","text":"CORS What is CORS? Cross-Origin Resource Sharing or CORS is an HTTP-header based mechanism that allows a server to indicate any other origins (domain, scheme, or port) than its own from which a browser should permit loading of resources. Why do we need CORS? When integrating an API, most developers have encountered the following error message: Access to fetch at RESOURCE_URL from origin ORIGIN_URL has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. This happens because the API ( RESOURCE_URL ) is not configured to accept requests from the client ( ORIGIN_URL ). How to fix? DotKernel API fixes this issue using the mezzio/mezzio-cors library. Step 1: Install library In order to install mezzio/mezzio-cors , run the following command: composer require mezzio/mezzio-cors Step 2: Configure your API Register ConfigProvider Register mezzio/mezzio-cors in your application by adding its ConfigProvider to your application's config aggregator. Open the file config/config.php and paste the below lines at the beginning of the array passed to ConfigAggregator : Laminas\\Diactoros\\ConfigProvider::class, Mezzio\\Cors\\ConfigProvider::class, Save and close the file. Add middleware Add mezzio/mezzio-cors middleware to your application's pipeline. Open config/pipeline.php and paste the below line before the one with RouteMiddleware::class : $app-&gt;pipe(\\Mezzio\\Cors\\Middleware\\CorsMiddleware::class); Save and close the file. Create config file Create and open file config/autoload/cors.local.php and add the following code inside it: &lt;?php declare(strict_types=1); use Mezzio\\Cors\\Configuration\\ConfigurationInterface; return [ ConfigurationInterface::CONFIGURATION_IDENTIFIER =&gt; [ 'allowed_origins' =&gt; [ ConfigurationInterface::ANY_ORIGIN, ], 'allowed_headers' =&gt; ['Accept', 'Content-Type', 'Authorization'], 'allowed_max_age' =&gt; '600', 'credentials_allowed' =&gt; true, 'exposed_headers' =&gt; [], ], ]; This list explains the above configuration values: allowed_origins : an array of domains that are allowed to interact with the API (default ConfigurationInterface::ANY_ORIGIN which means that any domain can make requests to the API) allowed_headers : an array of allowed custom headers allowed_max_age : the maximum duration, since the preflight response may be cached by a client credentials_allowed : allows a request to pass cookies exposed_headers : an array of headers which are being exposed by the endpoint Save and close the file. On the production environment, make sure you allow only specific origins by adding them to the allowed_origins array and removing the current value of ConfigurationInterface::ANY_ORIGIN . For more info, see mezzio/mezzio-cors documentation .","title":"CORS"},{"location":"v4/core-features/cors/#cors","text":"","title":"CORS"},{"location":"v4/core-features/cors/#what-is-cors","text":"Cross-Origin Resource Sharing or CORS is an HTTP-header based mechanism that allows a server to indicate any other origins (domain, scheme, or port) than its own from which a browser should permit loading of resources.","title":"What is CORS?"},{"location":"v4/core-features/cors/#why-do-we-need-cors","text":"When integrating an API, most developers have encountered the following error message: Access to fetch at RESOURCE_URL from origin ORIGIN_URL has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. This happens because the API ( RESOURCE_URL ) is not configured to accept requests from the client ( ORIGIN_URL ).","title":"Why do we need CORS?"},{"location":"v4/core-features/cors/#how-to-fix","text":"DotKernel API fixes this issue using the mezzio/mezzio-cors library.","title":"How to fix?"},{"location":"v4/core-features/exceptions/","text":"Exceptions What are exceptions? Exceptions are a powerful mechanism for handling errors and other exceptional conditions that may occur during the execution of a script. They provide a way to manage errors in a structured and controlled manner, separating error-handling code from regular code. How we use exceptions? When it comes to handling exceptions, DotKernel API relies on the usage of easy-to-understand, problem-specific exceptions. Out-of-the-box we provide the following custom exceptions: BadRequestException thrown when client tries to create/update resource, but the data from the request is invalid/incomplete (example: client tries to create an account, but does not send the required identity field) ConflictException thrown when resource cannot be created because a different resource with the same identifier already exists (example: cannot change existing user's identity because another user with the same identity already exists) resource cannot change its state because it is already in the specified state (example: user cannot be activated because it is already active) ExpiredException thrown when resource cannot be accessed because it expired (example: account activation link) resource cannot be accessed because it has been consumed (example: one-time password) ForbiddenException thrown when resource cannot be accessed by the authenticated client (example: client authenticated as regular user sends a GET /admin request) MethodNotAllowedException thrown when client tries to interact with a resource via an invalid HTTP request method (example: client sends a PATCH /avatar request) NotFoundException thrown when client tries to interact with a resource that does not exist on the server (example: client sends a GET /resource-does-not-exist request) UnauthorizedException thrown when resource cannot be accessed because the client is not authenticated (example: unauthenticated client sends a GET /admin request) How it works? During a request, if there is no uncaught exception DotKernel API will return a JSON response with the data provided by the handler that handled the request. Else, it will build and send a response based on the exception thrown: BadRequestException will return a 400 Bad Request response UnauthorizedException will return a 401 Unauthorized response ForbiddenException will return a 403 Forbidden response OutOfBoundsException and NotFoundException will return a 404 Not Found response MethodNotAllowedException will return a 405 Method Not Allowed response ConflictException will return a 409 Conflict response ExpiredException will return a 410 Gone response MailException , RuntimeException and the generic Exception will return a 500 Internal Server Error response How to extend? In this example we will create a custom exception called CustomException , place it next to the already existing custom exceptions (you can use your preferred location) and finally return a custom HTTP status code when CustomException is encountered. Step 1: Create exception file Navigate to the directory src/App/src/Handler/Exception and create a PHP class called CustomException.php . Open CustomException.php and add the following content: &lt;?php declare(strict_types=1); namespace Api\\App\\Exception; use Exception; class CustomException extends Exception { } Save and close the file. Step 2: Use exception file Open the file src/App/src/Handler/HomeHandler.php and at the beginning of the get method, place the following code: throw new \\Api\\App\\Exception\\CustomException('some message'); Save and close the file. Step 3: Test for failure Access your API's home page URL and make sure it returns 500 Internal Server Error HTTP status code and the following content: { \"error\": { \"messages\": [ \"some message\" ] } } Step 4: Prepare for success Open the file src/App/src/Handler/HandlerTrait.php and locate the handle method. Insert the following lines of code before the first catch statement: } catch (\\Api\\App\\Exception\\CustomException $exception) { return $this-&gt;errorResponse($exception-&gt;getMessage(), StatusCodeInterface::STATUS_IM_A_TEAPOT); Save and close the file. Step 5: Test for success Again, access your API's home page URL, which should return the same content. Notice that this time it returns 418 I'm a teapot HTTP status code.","title":"Exceptions"},{"location":"v4/core-features/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"v4/core-features/exceptions/#what-are-exceptions","text":"Exceptions are a powerful mechanism for handling errors and other exceptional conditions that may occur during the execution of a script. They provide a way to manage errors in a structured and controlled manner, separating error-handling code from regular code.","title":"What are exceptions?"},{"location":"v4/core-features/exceptions/#how-we-use-exceptions","text":"When it comes to handling exceptions, DotKernel API relies on the usage of easy-to-understand, problem-specific exceptions. Out-of-the-box we provide the following custom exceptions:","title":"How we use exceptions?"},{"location":"v4/core-features/exceptions/#how-it-works","text":"During a request, if there is no uncaught exception DotKernel API will return a JSON response with the data provided by the handler that handled the request. Else, it will build and send a response based on the exception thrown: BadRequestException will return a 400 Bad Request response UnauthorizedException will return a 401 Unauthorized response ForbiddenException will return a 403 Forbidden response OutOfBoundsException and NotFoundException will return a 404 Not Found response MethodNotAllowedException will return a 405 Method Not Allowed response ConflictException will return a 409 Conflict response ExpiredException will return a 410 Gone response MailException , RuntimeException and the generic Exception will return a 500 Internal Server Error response","title":"How it works?"},{"location":"v4/core-features/exceptions/#how-to-extend","text":"In this example we will create a custom exception called CustomException , place it next to the already existing custom exceptions (you can use your preferred location) and finally return a custom HTTP status code when CustomException is encountered.","title":"How to extend?"},{"location":"v4/flow/default-library-flow/","text":"Default Library Flow The graph below demonstrates a default flow between DotKernel's libraries.","title":"Default Library Flow"},{"location":"v4/flow/default-library-flow/#default-library-flow","text":"The graph below demonstrates a default flow between DotKernel's libraries.","title":"Default Library Flow"},{"location":"v4/flow/library-flow-for-email/","text":"Library Flow for Email The graph below demonstrates the simplified flow between DotKernel's libraries for sending an email.","title":"Library Flow for Email"},{"location":"v4/flow/library-flow-for-email/#library-flow-for-email","text":"The graph below demonstrates the simplified flow between DotKernel's libraries for sending an email.","title":"Library Flow for Email"},{"location":"v4/flow/middleware-flow/","text":"Middleware flow The graph below demonstrates a default flow between DotKernel's middlewares.","title":"Middleware Flow"},{"location":"v4/flow/middleware-flow/#middleware-flow","text":"The graph below demonstrates a default flow between DotKernel's middlewares.","title":"Middleware flow"},{"location":"v4/installation/composer/","text":"Composer Installation of Packages Install dependencies composer install Development mode If you're installing the project for development, make sure you have development mode enabled, by running: composer development-enable You can disable development mode by running: composer development-disable You can check if you have development mode enabled by running: composer development-status","title":"Composer"},{"location":"v4/installation/composer/#composer-installation-of-packages","text":"","title":"Composer Installation of Packages"},{"location":"v4/installation/composer/#install-dependencies","text":"composer install","title":"Install dependencies"},{"location":"v4/installation/composer/#development-mode","text":"If you're installing the project for development, make sure you have development mode enabled, by running: composer development-enable You can disable development mode by running: composer development-disable You can check if you have development mode enabled by running: composer development-status","title":"Development mode"},{"location":"v4/installation/configuration-files/","text":"Configuration Files Prepare config files duplicate config/autoload/cors.local.php.dist as config/autoload/cors.local.php Note if your API will be consumed by another application, make sure to configure the allowed_origins variable duplicate config/autoload/local.php.dist as config/autoload/local.php duplicate config/autoload/mail.local.php.dist as config/autoload/mail.local.php Note if your API will send emails, make sure to fill in SMTP connection params optional : in order to run/create tests, duplicate config/autoload/local.test.php.dist as config/autoload/local.test.php Note this creates a new in-memory database that your tests will run on.","title":"Configuration Files"},{"location":"v4/installation/configuration-files/#configuration-files","text":"","title":"Configuration Files"},{"location":"v4/installation/configuration-files/#prepare-config-files","text":"duplicate config/autoload/cors.local.php.dist as config/autoload/cors.local.php","title":"Prepare config files"},{"location":"v4/installation/doctrine-orm/","text":"Doctrine ORM Setup database Make sure you fill out the database credentials in config/autoload/local.php under $databases['default'] . Create a new MySQL database - set collation to utf8mb4_general_ci Running migrations Run the database migrations by using the following command: php vendor/bin/doctrine-migrations migrate This command will prompt you to confirm that you want to run it. WARNING! You are about to execute a migration in database \"...\" that could result in schema changes and data loss. Are you sure you wish to continue? (yes/no) [yes]: Hit Enter to confirm the operation. Executing fixtures Fixtures are used to seed the database with initial values and should be executed after migrating the database. To list all the fixtures, run: php bin/doctrine fixtures:list This will output all the fixtures in the order of execution. To execute all fixtures, run: php bin/doctrine fixtures:execute To execute a specific fixture, run: php bin/doctrine fixtures:execute --class=FixtureClassName More details on how fixtures work can be found here: https://github.com/dotkernel/dot-data-fixtures#creating-fixtures","title":"Doctrine ORM"},{"location":"v4/installation/doctrine-orm/#doctrine-orm","text":"","title":"Doctrine ORM"},{"location":"v4/installation/doctrine-orm/#setup-database","text":"Make sure you fill out the database credentials in config/autoload/local.php under $databases['default'] . Create a new MySQL database - set collation to utf8mb4_general_ci","title":"Setup database"},{"location":"v4/installation/doctrine-orm/#running-migrations","text":"Run the database migrations by using the following command: php vendor/bin/doctrine-migrations migrate This command will prompt you to confirm that you want to run it. WARNING! You are about to execute a migration in database \"...\" that could result in schema changes and data loss. Are you sure you wish to continue? (yes/no) [yes]: Hit Enter to confirm the operation.","title":"Running migrations"},{"location":"v4/installation/doctrine-orm/#executing-fixtures","text":"Fixtures are used to seed the database with initial values and should be executed after migrating the database. To list all the fixtures, run: php bin/doctrine fixtures:list This will output all the fixtures in the order of execution. To execute all fixtures, run: php bin/doctrine fixtures:execute To execute a specific fixture, run: php bin/doctrine fixtures:execute --class=FixtureClassName More details on how fixtures work can be found here: https://github.com/dotkernel/dot-data-fixtures#creating-fixtures","title":"Executing fixtures"},{"location":"v4/installation/faq/","text":"Frequently Asked Questions How do I fix common permission issues? If running your project you encounter some permission issues, follow the below steps. Errors PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data\" is not writable... PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data/cache\" is not writable... PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data/cache/doctrine\" is not writable... Fix: chmod -R 777 data Error PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/public/uploads\" is not writable... Fix: chmod -R 777 public/uploads Error PHP Fatal error: Uncaught ErrorException: fopen(/var/www/ example.local /config/autoload/../../log/error-log- yyyy-mm-dd.log ): Failed to open stream: Permission denied... Fix: chmod -R 777 log","title":"FAQ"},{"location":"v4/installation/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"v4/installation/faq/#how-do-i-fix-common-permission-issues","text":"If running your project you encounter some permission issues, follow the below steps.","title":"How do I fix common permission issues?"},{"location":"v4/installation/getting-started/","text":"Clone the project Using your terminal, navigate inside the directory you want to download the project files into. Make sure that the directory is empty before proceeding to the download process. Once there, run the following command: git clone https://github.com/dotkernel/api.git .","title":"Getting Started"},{"location":"v4/installation/getting-started/#clone-the-project","text":"Using your terminal, navigate inside the directory you want to download the project files into. Make sure that the directory is empty before proceeding to the download process. Once there, run the following command: git clone https://github.com/dotkernel/api.git .","title":"Clone the project"},{"location":"v4/installation/test-the-installation/","text":"Test the installation Sending a GET request to the home page should output the following message: {\"message\": \"DotKernel API version 4\"} Old way of doing things, using PHP built-in server php -S 0.0.0.0:8080 -t public Running tests The project has 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit Running unit tests vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always Running functional tests vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Test the Installation"},{"location":"v4/installation/test-the-installation/#test-the-installation","text":"Sending a GET request to the home page should output the following message: {\"message\": \"DotKernel API version 4\"}","title":"Test the installation"},{"location":"v4/installation/test-the-installation/#old-way-of-doing-things-using-php-built-in-server","text":"php -S 0.0.0.0:8080 -t public","title":"Old way of doing things, using PHP built-in server"},{"location":"v4/installation/test-the-installation/#running-tests","text":"The project has 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit","title":"Running tests"},{"location":"v4/installation/test-the-installation/#running-unit-tests","text":"vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always","title":"Running unit tests"},{"location":"v4/installation/test-the-installation/#running-functional-tests","text":"vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Running functional tests"},{"location":"v4/introduction/file-structure/","text":"File structure Dotkernel API follows the PSR-4 standards. It is a good practice to standardize the file structure of projects. When using DotKernel API the following structure is installed by default: Main directories bin - executable files from CLI config - various configuration files data - should contain project-related data (AVOID storing sensitive data on VCS) documentation - should contain project-related documentation log - storage of log files generated by dot-error-log library public - publicly visible files. The webserver need to have this folder as www-document root folder. src - should contain the source code files test - should contain the test files Special purpose folders .github - containes workflow files .laminas-ci - contains laminas-ci workflow files src directory This directory contains all source code related to the Module. It should contain following directories, if they’re not empty: Handler - Action classes (similar to Controllers but can only perform one action) Entity - For database entities Service - Service classes Collection - Database entities collections Repository - Entity repository folder The above example is just some of the directories a project may include, but these should give you an idea of how the structure should look like. Other classes in the src directory may include InputFilter , EventListener , Helper , Command , Factory etc. The src directory should also contain 2 files: ConfigProvider.php - Provides configuration data RoutesDelegator.php - Module main routes entry file templates directory This directory contains the template files, used for example to help render e-mail templates. DotKernel API uses twig as Templating Engine. All template files have the extension .html.twig data directory This directory contains project-related data (such as cache, file uploads) We recommend using the following directory structure: data/cache - location where caches are stored data/oauth - encryption, private and public keys needed for authentication. data/doctrine - fixtures and migrations data/lock - lock files generated by dotkernel/dot-cli See more","title":"File Structure"},{"location":"v4/introduction/file-structure/#file-structure","text":"Dotkernel API follows the PSR-4 standards. It is a good practice to standardize the file structure of projects. When using DotKernel API the following structure is installed by default:","title":"File structure"},{"location":"v4/introduction/file-structure/#main-directories","text":"bin - executable files from CLI config - various configuration files data - should contain project-related data (AVOID storing sensitive data on VCS) documentation - should contain project-related documentation log - storage of log files generated by dot-error-log library public - publicly visible files. The webserver need to have this folder as www-document root folder. src - should contain the source code files test - should contain the test files","title":"Main directories"},{"location":"v4/introduction/file-structure/#special-purpose-folders","text":".github - containes workflow files .laminas-ci - contains laminas-ci workflow files","title":"Special purpose folders"},{"location":"v4/introduction/file-structure/#src-directory","text":"This directory contains all source code related to the Module. It should contain following directories, if they’re not empty: Handler - Action classes (similar to Controllers but can only perform one action) Entity - For database entities Service - Service classes Collection - Database entities collections Repository - Entity repository folder The above example is just some of the directories a project may include, but these should give you an idea of how the structure should look like. Other classes in the src directory may include InputFilter , EventListener , Helper , Command , Factory etc. The src directory should also contain 2 files: ConfigProvider.php - Provides configuration data RoutesDelegator.php - Module main routes entry file","title":"src directory"},{"location":"v4/introduction/file-structure/#templates-directory","text":"This directory contains the template files, used for example to help render e-mail templates. DotKernel API uses twig as Templating Engine. All template files have the extension .html.twig","title":"templates directory"},{"location":"v4/introduction/file-structure/#data-directory","text":"This directory contains project-related data (such as cache, file uploads) We recommend using the following directory structure: data/cache - location where caches are stored data/oauth - encryption, private and public keys needed for authentication. data/doctrine - fixtures and migrations data/lock - lock files generated by dotkernel/dot-cli See more","title":"data directory"},{"location":"v4/introduction/introduction/","text":"Introduction Based on Enrico Zimuel’s Zend Expressive API – Skeleton example, DotKernel API runs on Laminas and Mezzio components and implements standards like PSR-3, PSR-4, PSR-7, PSR-11 and PSR-15. Here is a list of the core components: Middleware Microframework (mezzio/mezzio) Error Handler (dotkernel/dot-errorhandler) Problem Details (mezzio/mezzio-problem-details) CORS (mezzio/mezzio-cors) Routing (mezzio/mezzio-fastroute) Authentication (mezzio/mezzio-authentication) Authorization (mezzio/mezzio-authorization) Config Aggregator (laminas/laminas-config-aggregator) Container (roave/psr-container-doctrine) Annotations (dotkernel/dot-annotated-services) Input Filter (laminas/laminas-inputfilter) Doctrine 2 ORM (doctrine/orm) Serializer/Deserializer (laminas/laminas-hydrator) Paginator (laminas/laminas-paginator) HAL (mezzio/mezzio-hal) CLI (dotkernel/dot-cli) TwigRenderer (mezzio/mezzio-twigrenderer) Fixtures (dotkernel/dot-data-fixtures) UUID (ramsey/uuid-doctrine) Doctrine 2 ORM For the persistence in a relational database management system we chose Doctrine ORM (object-relational mapper). The benefit of Doctrine for the programmer is the ability to focus on the object-oriented business logic and worry about persistence only as a secondary priority. Documentation Our documentation is Postman based. We use the following files in which we store information about every available endpoint ready to be tested: documentation/DotKernel_API.postman_collection.json documentation/DotKernel_API.postman_environment.json Hypertext Application Language For our API payloads (a value object for describing the API resource, its relational links and any embedded/child resources related to it) we chose mezzio-hal. CORS By using MezzioCorsMiddlewareCorsMiddleware , the CORS preflight will be recognized and the middleware will start to detect the proper CORS configuration. The Router is used to detect every allowed request method by executing a route match with all possible request methods. Therefore, for every preflight request, there is at least one Router request. OAuth 2.0 OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on your DotKernel API. We are using mezzio/mezzio-authentication-oauth2 which provides OAuth 2.0 authentication for Mezzio and PSR-7/PSR-15 applications by using league/oauth2-server package. Email It is not unlikely for an API to send emails depending on the use case. Here is another area where DotKernel API shines. Using DotMailServiceMailService provided by dotkernel/dot-mail you can easily send custom email templates. Configuration From authorization at request route level to API keys for your application, you can find every configuration variable in the config directory. Registering a new module can be done by including its ConfigProvider.php in config.php. Brand new middlewares should go into pipeline.php. Here you can edit the order in which they run and find more info about the currently included ones. You can further customize your api within the autoload directory where each configuration category has its own file. Routing Each module has a RoutesDelegator.php file for managing existing routes inside that specific module. It also allows a quick way of adding new routes by providing the route path, Middlewares that the route will use and the route name. You can allocate permissions per route name in order to restrict access for a user role to a specific route in config/autoload/authorization.global.php . Commands For registering new commands first make sure your command class extends SymfonyComponentConsoleCommandCommand . Then you can enable it by registering it in config/autoload/cli.global.php . File locker Here you will also find our brand-new file locker configuration, so you can easily turn it on or off (by default: 'enabled' =&gt; true ). Note: The File Locker System will create a command-{command-default-name}.lock file which will not let another instance of the same command to run until the previous one has finished. PSR Standards PSR-3 : Logger Interface – the application uses LoggerInterface for error logging PSR-4 : Autoloader – the application locates classes using an autoloader PSR-7 : HTTP message interfaces – the handlers return ResponseInterface PSR-11 : Container interface – the application is container-based PSR-15 : HTTP Server Request Handlers – the handlers implement RequestHandlerInterface Tests One of the best ways to ensure the quality of your product is to create and run functional and unit tests. You can find factory-made tests in the tests/AppTest/ folder, and you can also register your own. We have 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit Running unit tests vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always Running functional tests vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Introduction"},{"location":"v4/introduction/introduction/#introduction","text":"Based on Enrico Zimuel’s Zend Expressive API – Skeleton example, DotKernel API runs on Laminas and Mezzio components and implements standards like PSR-3, PSR-4, PSR-7, PSR-11 and PSR-15. Here is a list of the core components: Middleware Microframework (mezzio/mezzio) Error Handler (dotkernel/dot-errorhandler) Problem Details (mezzio/mezzio-problem-details) CORS (mezzio/mezzio-cors) Routing (mezzio/mezzio-fastroute) Authentication (mezzio/mezzio-authentication) Authorization (mezzio/mezzio-authorization) Config Aggregator (laminas/laminas-config-aggregator) Container (roave/psr-container-doctrine) Annotations (dotkernel/dot-annotated-services) Input Filter (laminas/laminas-inputfilter) Doctrine 2 ORM (doctrine/orm) Serializer/Deserializer (laminas/laminas-hydrator) Paginator (laminas/laminas-paginator) HAL (mezzio/mezzio-hal) CLI (dotkernel/dot-cli) TwigRenderer (mezzio/mezzio-twigrenderer) Fixtures (dotkernel/dot-data-fixtures) UUID (ramsey/uuid-doctrine)","title":"Introduction"},{"location":"v4/introduction/introduction/#doctrine-2-orm","text":"For the persistence in a relational database management system we chose Doctrine ORM (object-relational mapper). The benefit of Doctrine for the programmer is the ability to focus on the object-oriented business logic and worry about persistence only as a secondary priority.","title":"Doctrine 2 ORM"},{"location":"v4/introduction/introduction/#documentation","text":"Our documentation is Postman based. We use the following files in which we store information about every available endpoint ready to be tested: documentation/DotKernel_API.postman_collection.json documentation/DotKernel_API.postman_environment.json","title":"Documentation"},{"location":"v4/introduction/introduction/#hypertext-application-language","text":"For our API payloads (a value object for describing the API resource, its relational links and any embedded/child resources related to it) we chose mezzio-hal.","title":"Hypertext Application Language"},{"location":"v4/introduction/introduction/#cors","text":"By using MezzioCorsMiddlewareCorsMiddleware , the CORS preflight will be recognized and the middleware will start to detect the proper CORS configuration. The Router is used to detect every allowed request method by executing a route match with all possible request methods. Therefore, for every preflight request, there is at least one Router request.","title":"CORS"},{"location":"v4/introduction/introduction/#oauth-20","text":"OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on your DotKernel API. We are using mezzio/mezzio-authentication-oauth2 which provides OAuth 2.0 authentication for Mezzio and PSR-7/PSR-15 applications by using league/oauth2-server package.","title":"OAuth 2.0"},{"location":"v4/introduction/introduction/#email","text":"It is not unlikely for an API to send emails depending on the use case. Here is another area where DotKernel API shines. Using DotMailServiceMailService provided by dotkernel/dot-mail you can easily send custom email templates.","title":"Email"},{"location":"v4/introduction/introduction/#configuration","text":"From authorization at request route level to API keys for your application, you can find every configuration variable in the config directory. Registering a new module can be done by including its ConfigProvider.php in config.php. Brand new middlewares should go into pipeline.php. Here you can edit the order in which they run and find more info about the currently included ones. You can further customize your api within the autoload directory where each configuration category has its own file.","title":"Configuration"},{"location":"v4/introduction/introduction/#routing","text":"Each module has a RoutesDelegator.php file for managing existing routes inside that specific module. It also allows a quick way of adding new routes by providing the route path, Middlewares that the route will use and the route name. You can allocate permissions per route name in order to restrict access for a user role to a specific route in config/autoload/authorization.global.php .","title":"Routing"},{"location":"v4/introduction/introduction/#commands","text":"For registering new commands first make sure your command class extends SymfonyComponentConsoleCommandCommand . Then you can enable it by registering it in config/autoload/cli.global.php .","title":"Commands"},{"location":"v4/introduction/introduction/#file-locker","text":"Here you will also find our brand-new file locker configuration, so you can easily turn it on or off (by default: 'enabled' =&gt; true ). Note: The File Locker System will create a command-{command-default-name}.lock file which will not let another instance of the same command to run until the previous one has finished.","title":"File locker"},{"location":"v4/introduction/introduction/#psr-standards","text":"PSR-3 : Logger Interface – the application uses LoggerInterface for error logging PSR-4 : Autoloader – the application locates classes using an autoloader PSR-7 : HTTP message interfaces – the handlers return ResponseInterface PSR-11 : Container interface – the application is container-based PSR-15 : HTTP Server Request Handlers – the handlers implement RequestHandlerInterface","title":"PSR Standards"},{"location":"v4/introduction/introduction/#tests","text":"One of the best ways to ensure the quality of your product is to create and run functional and unit tests. You can find factory-made tests in the tests/AppTest/ folder, and you can also register your own. We have 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit","title":"Tests"},{"location":"v4/introduction/introduction/#running-unit-tests","text":"vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always","title":"Running unit tests"},{"location":"v4/introduction/introduction/#running-functional-tests","text":"vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Running functional tests"},{"location":"v4/introduction/packages/","text":"Packages dotkernel/dot-annotated-services - Dependency injection component using class attributes. dotkernel/dot-cache - Cache component extending symfony-cache dotkernel/dot-cli - Component for creating console applications based on laminas-cli dotkernel/dot-data-fixtures - Provides a CLI interface for listing &amp; executing doctrine data fixtures dotkernel/dot-errorhandler - Logging Error Handler for Middleware Applications dotkernel/dot-mail - Mail component based on laminas-mail dotkernel/dot-response-header - Middleware for setting custom response headers. laminas/laminas-component-installer - Composer plugin for injecting modules and configuration providers into application configuration laminas/laminas-config - Provides a nested object property based user interface for accessing this configuration data within application code laminas/laminas-config-aggregator - Lightweight library for collecting and merging configuration from different sources laminas/laminas-http - Provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests laminas/laminas-hydrator - Serialize objects to arrays, and vice versa laminas/laminas-inputfilter - Normalize and validate input sets from the web, APIs, the CLI, and more, including files laminas/laminas-paginator - Paginate collections of data from arbitrary sources laminas/laminas-stdlib - SPL extensions, array utilities, error handlers, and more laminas/laminas-text - Create FIGlets and text-based tables mezzio/mezzio - PSR-15 Middleware Microframework mezzio/mezzio-authentication-oauth2 - OAuth2 (server) authentication middleware for Mezzio and PSR-7 applications mezzio/mezzio-authorization-acl - laminas-permissions-acl adapter for mezzio-authorization mezzio/mezzio-authorization-rbac - mezzio authorization rbac adapter for laminas/laminas-permissions-rbac mezzio/mezzio-cors - CORS component for Mezzio and other PSR-15 middleware runners mezzio/mezzio-fastroute - FastRoute integration for Mezzio mezzio/mezzio-hal - Hypertext Application Language implementation for PHP and PSR-7 mezzio/mezzio-problem-details - Problem Details for PSR-7 HTTP APIs addressing the RFC 7807 standard mezzio/mezzio-twigrenderer - Twig integration for Mezzio ramsey/uuid-doctrine - Use ramsey/uuid as a Doctrine field type roave/psr-container-doctrine - Doctrine Factories for PSR-11 Containers symfony/filesystem - Provides basic utilities for the filesystem","title":"Packages"},{"location":"v4/introduction/packages/#packages","text":"dotkernel/dot-annotated-services - Dependency injection component using class attributes. dotkernel/dot-cache - Cache component extending symfony-cache dotkernel/dot-cli - Component for creating console applications based on laminas-cli dotkernel/dot-data-fixtures - Provides a CLI interface for listing &amp; executing doctrine data fixtures dotkernel/dot-errorhandler - Logging Error Handler for Middleware Applications dotkernel/dot-mail - Mail component based on laminas-mail dotkernel/dot-response-header - Middleware for setting custom response headers. laminas/laminas-component-installer - Composer plugin for injecting modules and configuration providers into application configuration laminas/laminas-config - Provides a nested object property based user interface for accessing this configuration data within application code laminas/laminas-config-aggregator - Lightweight library for collecting and merging configuration from different sources laminas/laminas-http - Provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests laminas/laminas-hydrator - Serialize objects to arrays, and vice versa laminas/laminas-inputfilter - Normalize and validate input sets from the web, APIs, the CLI, and more, including files laminas/laminas-paginator - Paginate collections of data from arbitrary sources laminas/laminas-stdlib - SPL extensions, array utilities, error handlers, and more laminas/laminas-text - Create FIGlets and text-based tables mezzio/mezzio - PSR-15 Middleware Microframework mezzio/mezzio-authentication-oauth2 - OAuth2 (server) authentication middleware for Mezzio and PSR-7 applications mezzio/mezzio-authorization-acl - laminas-permissions-acl adapter for mezzio-authorization mezzio/mezzio-authorization-rbac - mezzio authorization rbac adapter for laminas/laminas-permissions-rbac mezzio/mezzio-cors - CORS component for Mezzio and other PSR-15 middleware runners mezzio/mezzio-fastroute - FastRoute integration for Mezzio mezzio/mezzio-hal - Hypertext Application Language implementation for PHP and PSR-7 mezzio/mezzio-problem-details - Problem Details for PSR-7 HTTP APIs addressing the RFC 7807 standard mezzio/mezzio-twigrenderer - Twig integration for Mezzio ramsey/uuid-doctrine - Use ramsey/uuid as a Doctrine field type roave/psr-container-doctrine - Doctrine Factories for PSR-11 Containers symfony/filesystem - Provides basic utilities for the filesystem","title":"Packages"},{"location":"v4/introduction/server-requirements/","text":"Server Requirements For production, we highly recommend a *nix based system. Webserver Apache &gt;= 2.2 or Nginx mod_rewrite .htaccess support (AllowOverride All) PHP &gt;= 8.2 Both mod_php and FCGI (FPM) are supported. Required Settings and Modules &amp; Extensions memory_limit &gt;= 128M upload_max_filesize and post_max_size &gt;= 100M (depending on your data) mbstring CLI SAPI (for Cron Jobs) Composer (added to $PATH) RDBMS MySQL / MariaDB &gt;= 5.5.3 Recommended extensions opcache pdo_mysql or mysqli (if using MySQL or MariaDB as RDBMS) dom - if working with markup files structure (html, xml, etc) simplexml - working with xml files gd, exif - if working with images zlib, zip, bz2 - if compessing files curl (required if APIs are used)","title":"Server Requirements"},{"location":"v4/introduction/server-requirements/#server-requirements","text":"For production, we highly recommend a *nix based system.","title":"Server Requirements"},{"location":"v4/introduction/server-requirements/#webserver","text":"Apache &gt;= 2.2 or Nginx mod_rewrite .htaccess support (AllowOverride All)","title":"Webserver"},{"location":"v4/introduction/server-requirements/#php-82","text":"Both mod_php and FCGI (FPM) are supported.","title":"PHP &gt;= 8.2"},{"location":"v4/introduction/server-requirements/#required-settings-and-modules-extensions","text":"memory_limit &gt;= 128M upload_max_filesize and post_max_size &gt;= 100M (depending on your data) mbstring CLI SAPI (for Cron Jobs) Composer (added to $PATH)","title":"Required Settings and Modules &amp; Extensions"},{"location":"v4/introduction/server-requirements/#rdbms","text":"MySQL / MariaDB &gt;= 5.5.3","title":"RDBMS"},{"location":"v4/introduction/server-requirements/#recommended-extensions","text":"opcache pdo_mysql or mysqli (if using MySQL or MariaDB as RDBMS) dom - if working with markup files structure (html, xml, etc) simplexml - working with xml files gd, exif - if working with images zlib, zip, bz2 - if compessing files curl (required if APIs are used)","title":"Recommended extensions"},{"location":"v4/transition-from-api-tools/api-tools-vs-dotkernel-api/","text":"Laminas API Tools compared to DotKernel API API Tools (formerly Apigility) DotKernel API URL api-tools Dotkernel API First Release 2012 2018 PHP Version &lt;= 8.2 &gt;= 8.1 Architecture MVC, Event Driven Middleware OSS Lifecycle Archived Style REST, RPC REST Versioning Yes Deprecations * Documentation Swagger (Automated) Postman (Manual) * Content-Negotiation Custom Custom License BSD-3 MIT Default DB Layer laminas-db doctrine-orm Authorization ACL RBAC-guard Authentication HTTP Basic/Digest OAuth2.0 OAuth2.0 CI/CD Yes Yes Unit Tests Yes Yes Endpoint Generator Yes Under development PSR PSR-7 PSR-7, PSR-15 Note Versioning is replaced by Deprecations, using evolution strategy Version 5 ( Roadmap ) will implement OpenAPi 3.0","title":"Laminas API Tools vs DotKernel API"},{"location":"v4/transition-from-api-tools/api-tools-vs-dotkernel-api/#laminas-api-tools-compared-to-dotkernel-api","text":"API Tools (formerly Apigility) DotKernel API URL api-tools Dotkernel API First Release 2012 2018 PHP Version &lt;= 8.2 &gt;= 8.1 Architecture MVC, Event Driven Middleware OSS Lifecycle Archived Style REST, RPC REST Versioning Yes Deprecations * Documentation Swagger (Automated) Postman (Manual) * Content-Negotiation Custom Custom License BSD-3 MIT Default DB Layer laminas-db doctrine-orm Authorization ACL RBAC-guard Authentication HTTP Basic/Digest OAuth2.0 OAuth2.0 CI/CD Yes Yes Unit Tests Yes Yes Endpoint Generator Yes Under development PSR PSR-7 PSR-7, PSR-15","title":"Laminas API Tools compared to DotKernel API"},{"location":"v4/transition-from-api-tools/api-tools-vs-dotkernel-api/#note","text":"Versioning is replaced by Deprecations, using evolution strategy Version 5 ( Roadmap ) will implement OpenAPi 3.0","title":"Note"},{"location":"v4/transition-from-api-tools/discovery-phase/","text":"Discovery phase for a current system built using API Tools [WIP] In order to transition a system built using api-tools to Dotkernel API , we need to analyze the core components of it. Database there is a database in the current API ? which is the connection to database which library is used for database interaction ( laminas-db, doctrine 2, eloquent, or else ) Note Dotkernel API is tested only with MariaDB version 10.6 and 10.11 LTS Authentication and Authorization how authentication is done ? (basic, digest, oauth2, etc.) how authorization is done ? (acl, rbac) Modules analyze configuration files of the modules (what needs to be configured in order to use a module) analyze routes (which are the routes, protection rules, which one need auth, etc.) analyze response format (content negotiation and validation, which ones are json, hal, views, etc.) analyze input field validations Custom functionalities Analyze the custom code (code that cannot be generated through Admin UI and require manual implementation) For instance: caching events services extra installed packages and libraries jobs and queues third-parties tests","title":"Discovery Phase"},{"location":"v4/transition-from-api-tools/discovery-phase/#discovery-phase-for-a-current-system-built-using-api-tools-wip","text":"In order to transition a system built using api-tools to Dotkernel API , we need to analyze the core components of it.","title":"Discovery phase for a current system built using API Tools [WIP]"},{"location":"v4/transition-from-api-tools/discovery-phase/#database","text":"there is a database in the current API ? which is the connection to database which library is used for database interaction ( laminas-db, doctrine 2, eloquent, or else )","title":"Database"},{"location":"v4/transition-from-api-tools/discovery-phase/#authentication-and-authorization","text":"how authentication is done ? (basic, digest, oauth2, etc.) how authorization is done ? (acl, rbac)","title":"Authentication and Authorization"},{"location":"v4/transition-from-api-tools/discovery-phase/#modules","text":"analyze configuration files of the modules (what needs to be configured in order to use a module) analyze routes (which are the routes, protection rules, which one need auth, etc.) analyze response format (content negotiation and validation, which ones are json, hal, views, etc.) analyze input field validations","title":"Modules"},{"location":"v4/transition-from-api-tools/discovery-phase/#custom-functionalities","text":"Analyze the custom code (code that cannot be generated through Admin UI and require manual implementation) For instance: caching events services extra installed packages and libraries jobs and queues third-parties tests","title":"Custom functionalities"},{"location":"v4/transition-from-api-tools/transition-approach/","text":"Transition approach [WIP] Dotkernel API is not a one-to-one replacement of api-tools ( former Apigility), but is only a potential solution to migrate to. Functionalities, components and architecture are different. See the Comparison between Dotkernel APi and api-tools Business cases There are at least 2 approaches for this transition: Clone 1:1 and recreate all endpoints and entities Build a new version of the current API using Dotkernel API and keep it running as separate platforms until the sunset of the current version of api-tools","title":"Transition Approach"},{"location":"v4/transition-from-api-tools/transition-approach/#transition-approach-wip","text":"Dotkernel API is not a one-to-one replacement of api-tools ( former Apigility), but is only a potential solution to migrate to. Functionalities, components and architecture are different. See the Comparison between Dotkernel APi and api-tools","title":"Transition approach [WIP]"},{"location":"v4/transition-from-api-tools/transition-approach/#business-cases","text":"There are at least 2 approaches for this transition:","title":"Business cases"},{"location":"v4/tutorials/create-book-module/","text":"Implementing a book module in DotKernel API File structure The below file structure is just an example, you can have multiple components such as event listeners, wrappers, etc. . └── src/ └── Book/ └── src/ ├── Collection/ │ └── BookCollection.php ├── Entity/ │ └── Book.php ├── Handler/ │ └── BookHandler.php ├── InputFilter/ │ ├── Input/ │ │ ├── AuthorInput.php │ │ ├── NameInput.php │ │ └── ReleaseDateInput.php │ └── BookInputFilter.php ├── Repository/ │ └── BookRepository.php ├── Service/ │ ├── BookService.php │ └── BookServiceInterface.php ├── ConfigProvider.php └── RoutesDelegator.php src/Book/src/Collection/BookCollection.php - a collection refers to a container for a group of related objects, typically used to manage sets of related entities fetched from a database src/Book/src/Entity/Book.php - an entity refers to a PHP class that represents a persistent object or data structure src/Book/src/Handler/BookHandler.php - handlers are middleware that can handle requests based on an action src/Book/src/Repository/BookRepository.php - a repository is a class responsible for querying and retrieving entities from the database src/Book/src/Service/BookService.php - is a class or component responsible for performing a specific task or providing functionality to other parts of the application src/Book/src/ConfigProvider.php - is a class that provides configuration for various aspects of the framework or application src/Book/src/RoutesDelegator.php - a routes delegator is a delegator factory responsible for configuring routing middleware based on routing configuration provided by the application src/Book/src/InputFilter/BookInputFilter.php - input filters and validators src/Book/src/InputFilter/Input/* - input filters and validator configurations File creation and contents src/Book/src/Collection/BookCollection.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Collection; use Api\\App\\Collection\\ResourceCollection; class BookCollection extends ResourceCollection { } src/Book/src/Entity/Book.php To keep things simple in this tutorial our book will have 3 properties: name , author and release date . &lt;?php declare(strict_types=1); namespace Api\\Book\\Entity; use Api\\App\\Entity\\AbstractEntity; use Api\\Book\\Repository\\BookRepository; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(\"book\")] class Book extends AbstractEntity { #[ORM\\Column(name: \"name\", type: \"string\", length: 100)] protected string $name; #[ORM\\Column(name: \"author\", type: \"string\", length: 100)] protected string $author; #[ORM\\Column(name: \"releaseDate\", type: \"datetime_immutable\")] protected DateTimeImmutable $releaseDate; public function __construct(string $name, string $author, DateTimeImmutable $releaseDate) { parent::__construct(); $this-&gt;setName($name); $this-&gt;setAuthor($author); $this-&gt;setReleaseDate($releaseDate); } public function getName(): string { return $this-&gt;name; } public function setName(string $name): self { $this-&gt;name = $name; return $this; } public function getAuthor(): string { return $this-&gt;author; } public function setAuthor(string $author): self { $this-&gt;author = $author; return $this; } public function getReleaseDate(): DateTimeImmutable { return $this-&gt;releaseDate; } public function setReleaseDate(DateTimeImmutable $releaseDate): self { $this-&gt;releaseDate = $releaseDate; return $this; } public function getArrayCopy(): array { return [ 'uuid' =&gt; $this-&gt;getUuid()-&gt;toString(), 'name' =&gt; $this-&gt;getName(), 'author' =&gt; $this-&gt;getAuthor(), 'releaseDate' =&gt; $this-&gt;getReleaseDate(), ]; } } src/Book/src/Repository/BookRepository.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Repository; use Api\\App\\Helper\\PaginationHelper; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Doctrine\\ORM\\EntityRepository; use Dot\\AnnotatedServices\\Annotation\\Entity; /** * @Entity(name=\"Api\\Book\\Entity\\Book\") * @extends EntityRepository&lt;object&gt; */ class BookRepository extends EntityRepository { public function saveBook(Book $book): Book { $this-&gt;getEntityManager()-&gt;persist($book); $this-&gt;getEntityManager()-&gt;flush(); return $book; } public function getBooks(array $filters = []): BookCollection { $page = PaginationHelper::getOffsetAndLimit($filters); $qb = $this -&gt;getEntityManager() -&gt;createQueryBuilder() -&gt;select('book') -&gt;from(Book::class, 'book') -&gt;orderBy($filters['order'] ?? 'book.created', $filters['dir'] ?? 'desc') -&gt;setFirstResult($page['offset']) -&gt;setMaxResults($page['limit']); $qb-&gt;getQuery()-&gt;useQueryCache(true); return new BookCollection($qb, false); } } src/Book/src/Service/BookService.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; use Api\\Book\\Entity\\Book; use Api\\Book\\Repository\\BookRepository; use Dot\\AnnotatedServices\\Annotation\\Inject; use DateTimeImmutable; class BookService implements BookServiceInterface { /** * @Inject({ * BookRepository::class, * }) */ public function __construct(protected BookRepository $bookRepository) { } public function createBook(array $data): Book { $book = new Book( $data['name'], $data['author'], new DateTimeImmutable($data['releaseDate']) ); return $this-&gt;bookRepository-&gt;saveBook($book); } public function getBooks(array $filters = []) { return $this-&gt;bookRepository-&gt;getBooks($filters); } } src/Book/src/Service/BookServiceInterface.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; interface BookServiceInterface { } src/Book/src/ConfigProvider.php &lt;?php declare(strict_types=1); namespace Api\\Book; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Api\\Book\\Handler\\BookHandler; use Api\\Book\\Repository\\BookRepository; use Api\\Book\\Service\\BookService; use Api\\Book\\Service\\BookServiceInterface; use Dot\\AnnotatedServices\\Factory\\AnnotatedRepositoryFactory; use Dot\\AnnotatedServices\\Factory\\AnnotatedServiceFactory; use Mezzio\\Hal\\Metadata\\MetadataMap; use Api\\App\\ConfigProvider as AppConfigProvider; class ConfigProvider { public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), MetadataMap::class =&gt; $this-&gt;getHalConfig(), ]; } public function getDependencies(): array { return [ 'factories' =&gt; [ BookHandler::class =&gt; AnnotatedServiceFactory::class, BookService::class =&gt; AnnotatedServiceFactory::class, BookRepository::class =&gt; AnnotatedRepositoryFactory::class, ], 'aliases' =&gt; [ BookServiceInterface::class =&gt; BookService::class, ], ]; } public function getHalConfig(): array { return [ AppConfigProvider::getCollection(BookCollection::class, 'books.list', 'books'), AppConfigProvider::getResource(Book::class, 'book.create'), ]; } } src/Book/src/RoutesDelegator.php &lt;?php namespace Api\\Book; use Api\\Book\\Handler\\BookHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { /** @var Application $app */ $app = $callback(); $app-&gt;get( '/books', BookHandler::class, 'books.list' ); $app-&gt;post( '/book', BookHandler::class, 'book.create' ); return $app; } } src/Book/src/InputFilter/BookInputFilter.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter; use Api\\Book\\InputFilter\\Input\\AuthorInput; use Api\\Book\\InputFilter\\Input\\NameInput; use Api\\Book\\InputFilter\\Input\\ReleaseDateInput; use Laminas\\InputFilter\\InputFilter; class BookInputFilter extends InputFilter { public function __construct() { $this-&gt;add(new NameInput('name')); $this-&gt;add(new AuthorInput('author')); $this-&gt;add(new ReleaseDateInput('releaseDate')); } } src/Book/src/InputFilter/Input/AuthorInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class AuthorInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'author'), ], true); } } src/Book/src/InputFilter/Input/NameInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class NameInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'name'), ], true); } } src/Book/src/InputFilter/Input/ReleaseDateInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\Date; use Laminas\\Validator\\NotEmpty; class ReleaseDateInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(Date::class, [ 'message' =&gt; sprintf(Message::INVALID_VALUE, 'releaseDate'), ], true); } } src/Book/src/Handler/BookHandler.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Handler; use Api\\App\\Handler\\ResponseTrait; use Api\\Book\\InputFilter\\BookInputFilter; use Api\\Book\\Service\\BookServiceInterface; use Mezzio\\Hal\\HalResponseFactory; use Mezzio\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Dot\\AnnotatedServices\\Annotation\\Inject; class BookHandler implements RequestHandlerInterface { use ResponseTrait; /** * @Inject({ * HalResponseFactory::class, * ResourceGenerator::class, * BookServiceInterface::class * }) */ public function __construct( protected HalResponseFactory $responseFactory, protected ResourceGenerator $resourceGenerator, protected BookServiceInterface $bookService ) { } public function get(ServerRequestInterface $request): ResponseInterface { $books = $this-&gt;bookService-&gt;getBooks($request-&gt;getQueryParams()); return $this-&gt;createResponse($request, $books); } public function post(ServerRequestInterface $request): ResponseInterface { $inputFilter = (new BookInputFilter())-&gt;setData($request-&gt;getParsedBody()); if (! $inputFilter-&gt;isValid()) { return $this-&gt;errorResponse($inputFilter-&gt;getMessages()); } $book = $this-&gt;bookService-&gt;createBook($inputFilter-&gt;getValues()); return $this-&gt;createResponse($request, $book); } } Configuring and registering the new module Once you set up all the files as in the example above, you will need to do a few additional configurations: register the namespace by adding this line \"Api\\\\Book\\\\\": \"src/Book/src/\", in composer.json under the autoload.psr-4 key register the module by adding Api\\Book\\ConfigProvider::class, under Api\\User\\ConfigProvider::class, register the module's routes by adding \\Api\\Book\\RoutesDelegator::class, under \\Api\\User\\RoutesDelegator::class, in src/App/src/ConfigProvider.php update Composer autoloader by running the command: composer dump-autoload It should look like this: public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, \\Api\\Admin\\RoutesDelegator::class, \\Api\\User\\RoutesDelegator::class, \\Api\\Book\\RoutesDelegator::class, ], ], 'factories' =&gt; [ ... ] ... In src/config/autoload/doctrine.global.php add this under the doctrine.driver key: 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], Api\\\\Book\\Entity' =&gt; 'BookEntities', add this under the doctrine.driver.drivers key Example: &lt;?php ... return [ 'doctrine' =&gt; [ ... 'driver' =&gt; [ 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, 'drivers' =&gt; [ 'Api\\\\App\\Entity' =&gt; 'AppEntities', 'Api\\\\Admin\\\\Entity' =&gt; 'AdminEntities', 'Api\\\\User\\\\Entity' =&gt; 'UserEntities', 'Api\\\\Book\\Entity' =&gt; 'BookEntities', ], ], 'AdminEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Admin/src/Entity', ], 'UserEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/User/src/Entity', ], 'AppEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/App/src/Entity', ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], ], ... Next we need to configure access to the newly created endpoints, add books.list and book.create to the authorization rbac array, under the UserRole::ROLE_GUEST key. Make sure you read and understand the rbac documentation. Migrations We created the Book entity, but we didn't create the associated table for it. Doctrine can handle the table creation, run the following command: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' This will check for differences between your entities and database structure and create migration files if necessary, in data/doctrine/migrations . To execute the migrations run: vendor/bin/doctrine-migrations migrate Checking endpoints If we did everything as planned we can call the http://0.0.0.0:8080/book endpoint and create a new book: curl -X POST http://0.0.0.0:8080/book -H \"Content-Type: application/json\" -d '{\"name\": \"test\", \"author\": \"author name\", \"releaseDate\": \"2023-03-03\"}' To list the books use: curl http://0.0.0.0:8080/books","title":"Creating a book module"},{"location":"v4/tutorials/create-book-module/#implementing-a-book-module-in-dotkernel-api","text":"","title":"Implementing a book module in DotKernel API"},{"location":"v4/tutorials/create-book-module/#file-structure","text":"The below file structure is just an example, you can have multiple components such as event listeners, wrappers, etc. . └── src/ └── Book/ └── src/ ├── Collection/ │ └── BookCollection.php ├── Entity/ │ └── Book.php ├── Handler/ │ └── BookHandler.php ├── InputFilter/ │ ├── Input/ │ │ ├── AuthorInput.php │ │ ├── NameInput.php │ │ └── ReleaseDateInput.php │ └── BookInputFilter.php ├── Repository/ │ └── BookRepository.php ├── Service/ │ ├── BookService.php │ └── BookServiceInterface.php ├── ConfigProvider.php └── RoutesDelegator.php src/Book/src/Collection/BookCollection.php - a collection refers to a container for a group of related objects, typically used to manage sets of related entities fetched from a database src/Book/src/Entity/Book.php - an entity refers to a PHP class that represents a persistent object or data structure src/Book/src/Handler/BookHandler.php - handlers are middleware that can handle requests based on an action src/Book/src/Repository/BookRepository.php - a repository is a class responsible for querying and retrieving entities from the database src/Book/src/Service/BookService.php - is a class or component responsible for performing a specific task or providing functionality to other parts of the application src/Book/src/ConfigProvider.php - is a class that provides configuration for various aspects of the framework or application src/Book/src/RoutesDelegator.php - a routes delegator is a delegator factory responsible for configuring routing middleware based on routing configuration provided by the application src/Book/src/InputFilter/BookInputFilter.php - input filters and validators src/Book/src/InputFilter/Input/* - input filters and validator configurations","title":"File structure"},{"location":"v4/tutorials/create-book-module/#file-creation-and-contents","text":"src/Book/src/Collection/BookCollection.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Collection; use Api\\App\\Collection\\ResourceCollection; class BookCollection extends ResourceCollection { } src/Book/src/Entity/Book.php To keep things simple in this tutorial our book will have 3 properties: name , author and release date . &lt;?php declare(strict_types=1); namespace Api\\Book\\Entity; use Api\\App\\Entity\\AbstractEntity; use Api\\Book\\Repository\\BookRepository; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(\"book\")] class Book extends AbstractEntity { #[ORM\\Column(name: \"name\", type: \"string\", length: 100)] protected string $name; #[ORM\\Column(name: \"author\", type: \"string\", length: 100)] protected string $author; #[ORM\\Column(name: \"releaseDate\", type: \"datetime_immutable\")] protected DateTimeImmutable $releaseDate; public function __construct(string $name, string $author, DateTimeImmutable $releaseDate) { parent::__construct(); $this-&gt;setName($name); $this-&gt;setAuthor($author); $this-&gt;setReleaseDate($releaseDate); } public function getName(): string { return $this-&gt;name; } public function setName(string $name): self { $this-&gt;name = $name; return $this; } public function getAuthor(): string { return $this-&gt;author; } public function setAuthor(string $author): self { $this-&gt;author = $author; return $this; } public function getReleaseDate(): DateTimeImmutable { return $this-&gt;releaseDate; } public function setReleaseDate(DateTimeImmutable $releaseDate): self { $this-&gt;releaseDate = $releaseDate; return $this; } public function getArrayCopy(): array { return [ 'uuid' =&gt; $this-&gt;getUuid()-&gt;toString(), 'name' =&gt; $this-&gt;getName(), 'author' =&gt; $this-&gt;getAuthor(), 'releaseDate' =&gt; $this-&gt;getReleaseDate(), ]; } } src/Book/src/Repository/BookRepository.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Repository; use Api\\App\\Helper\\PaginationHelper; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Doctrine\\ORM\\EntityRepository; use Dot\\AnnotatedServices\\Annotation\\Entity; /** * @Entity(name=\"Api\\Book\\Entity\\Book\") * @extends EntityRepository&lt;object&gt; */ class BookRepository extends EntityRepository { public function saveBook(Book $book): Book { $this-&gt;getEntityManager()-&gt;persist($book); $this-&gt;getEntityManager()-&gt;flush(); return $book; } public function getBooks(array $filters = []): BookCollection { $page = PaginationHelper::getOffsetAndLimit($filters); $qb = $this -&gt;getEntityManager() -&gt;createQueryBuilder() -&gt;select('book') -&gt;from(Book::class, 'book') -&gt;orderBy($filters['order'] ?? 'book.created', $filters['dir'] ?? 'desc') -&gt;setFirstResult($page['offset']) -&gt;setMaxResults($page['limit']); $qb-&gt;getQuery()-&gt;useQueryCache(true); return new BookCollection($qb, false); } } src/Book/src/Service/BookService.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; use Api\\Book\\Entity\\Book; use Api\\Book\\Repository\\BookRepository; use Dot\\AnnotatedServices\\Annotation\\Inject; use DateTimeImmutable; class BookService implements BookServiceInterface { /** * @Inject({ * BookRepository::class, * }) */ public function __construct(protected BookRepository $bookRepository) { } public function createBook(array $data): Book { $book = new Book( $data['name'], $data['author'], new DateTimeImmutable($data['releaseDate']) ); return $this-&gt;bookRepository-&gt;saveBook($book); } public function getBooks(array $filters = []) { return $this-&gt;bookRepository-&gt;getBooks($filters); } } src/Book/src/Service/BookServiceInterface.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; interface BookServiceInterface { } src/Book/src/ConfigProvider.php &lt;?php declare(strict_types=1); namespace Api\\Book; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Api\\Book\\Handler\\BookHandler; use Api\\Book\\Repository\\BookRepository; use Api\\Book\\Service\\BookService; use Api\\Book\\Service\\BookServiceInterface; use Dot\\AnnotatedServices\\Factory\\AnnotatedRepositoryFactory; use Dot\\AnnotatedServices\\Factory\\AnnotatedServiceFactory; use Mezzio\\Hal\\Metadata\\MetadataMap; use Api\\App\\ConfigProvider as AppConfigProvider; class ConfigProvider { public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), MetadataMap::class =&gt; $this-&gt;getHalConfig(), ]; } public function getDependencies(): array { return [ 'factories' =&gt; [ BookHandler::class =&gt; AnnotatedServiceFactory::class, BookService::class =&gt; AnnotatedServiceFactory::class, BookRepository::class =&gt; AnnotatedRepositoryFactory::class, ], 'aliases' =&gt; [ BookServiceInterface::class =&gt; BookService::class, ], ]; } public function getHalConfig(): array { return [ AppConfigProvider::getCollection(BookCollection::class, 'books.list', 'books'), AppConfigProvider::getResource(Book::class, 'book.create'), ]; } } src/Book/src/RoutesDelegator.php &lt;?php namespace Api\\Book; use Api\\Book\\Handler\\BookHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { /** @var Application $app */ $app = $callback(); $app-&gt;get( '/books', BookHandler::class, 'books.list' ); $app-&gt;post( '/book', BookHandler::class, 'book.create' ); return $app; } } src/Book/src/InputFilter/BookInputFilter.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter; use Api\\Book\\InputFilter\\Input\\AuthorInput; use Api\\Book\\InputFilter\\Input\\NameInput; use Api\\Book\\InputFilter\\Input\\ReleaseDateInput; use Laminas\\InputFilter\\InputFilter; class BookInputFilter extends InputFilter { public function __construct() { $this-&gt;add(new NameInput('name')); $this-&gt;add(new AuthorInput('author')); $this-&gt;add(new ReleaseDateInput('releaseDate')); } } src/Book/src/InputFilter/Input/AuthorInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class AuthorInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'author'), ], true); } } src/Book/src/InputFilter/Input/NameInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class NameInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'name'), ], true); } } src/Book/src/InputFilter/Input/ReleaseDateInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\Date; use Laminas\\Validator\\NotEmpty; class ReleaseDateInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(Date::class, [ 'message' =&gt; sprintf(Message::INVALID_VALUE, 'releaseDate'), ], true); } } src/Book/src/Handler/BookHandler.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Handler; use Api\\App\\Handler\\ResponseTrait; use Api\\Book\\InputFilter\\BookInputFilter; use Api\\Book\\Service\\BookServiceInterface; use Mezzio\\Hal\\HalResponseFactory; use Mezzio\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Dot\\AnnotatedServices\\Annotation\\Inject; class BookHandler implements RequestHandlerInterface { use ResponseTrait; /** * @Inject({ * HalResponseFactory::class, * ResourceGenerator::class, * BookServiceInterface::class * }) */ public function __construct( protected HalResponseFactory $responseFactory, protected ResourceGenerator $resourceGenerator, protected BookServiceInterface $bookService ) { } public function get(ServerRequestInterface $request): ResponseInterface { $books = $this-&gt;bookService-&gt;getBooks($request-&gt;getQueryParams()); return $this-&gt;createResponse($request, $books); } public function post(ServerRequestInterface $request): ResponseInterface { $inputFilter = (new BookInputFilter())-&gt;setData($request-&gt;getParsedBody()); if (! $inputFilter-&gt;isValid()) { return $this-&gt;errorResponse($inputFilter-&gt;getMessages()); } $book = $this-&gt;bookService-&gt;createBook($inputFilter-&gt;getValues()); return $this-&gt;createResponse($request, $book); } }","title":"File creation and contents"},{"location":"v4/tutorials/create-book-module/#configuring-and-registering-the-new-module","text":"Once you set up all the files as in the example above, you will need to do a few additional configurations: register the namespace by adding this line \"Api\\\\Book\\\\\": \"src/Book/src/\", in composer.json under the autoload.psr-4 key register the module by adding Api\\Book\\ConfigProvider::class, under Api\\User\\ConfigProvider::class, register the module's routes by adding \\Api\\Book\\RoutesDelegator::class, under \\Api\\User\\RoutesDelegator::class, in src/App/src/ConfigProvider.php update Composer autoloader by running the command: composer dump-autoload It should look like this: public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, \\Api\\Admin\\RoutesDelegator::class, \\Api\\User\\RoutesDelegator::class, \\Api\\Book\\RoutesDelegator::class, ], ], 'factories' =&gt; [ ... ] ... In src/config/autoload/doctrine.global.php add this under the doctrine.driver key: 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], Api\\\\Book\\Entity' =&gt; 'BookEntities', add this under the doctrine.driver.drivers key Example: &lt;?php ... return [ 'doctrine' =&gt; [ ... 'driver' =&gt; [ 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, 'drivers' =&gt; [ 'Api\\\\App\\Entity' =&gt; 'AppEntities', 'Api\\\\Admin\\\\Entity' =&gt; 'AdminEntities', 'Api\\\\User\\\\Entity' =&gt; 'UserEntities', 'Api\\\\Book\\Entity' =&gt; 'BookEntities', ], ], 'AdminEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Admin/src/Entity', ], 'UserEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/User/src/Entity', ], 'AppEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/App/src/Entity', ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], ], ... Next we need to configure access to the newly created endpoints, add books.list and book.create to the authorization rbac array, under the UserRole::ROLE_GUEST key. Make sure you read and understand the rbac documentation.","title":"Configuring and registering the new module"},{"location":"v4/tutorials/create-book-module/#migrations","text":"We created the Book entity, but we didn't create the associated table for it. Doctrine can handle the table creation, run the following command: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' This will check for differences between your entities and database structure and create migration files if necessary, in data/doctrine/migrations . To execute the migrations run: vendor/bin/doctrine-migrations migrate","title":"Migrations"},{"location":"v4/tutorials/create-book-module/#checking-endpoints","text":"If we did everything as planned we can call the http://0.0.0.0:8080/book endpoint and create a new book: curl -X POST http://0.0.0.0:8080/book -H \"Content-Type: application/json\" -d '{\"name\": \"test\", \"author\": \"author name\", \"releaseDate\": \"2023-03-03\"}' To list the books use: curl http://0.0.0.0:8080/books","title":"Checking endpoints"},{"location":"v4/tutorials/token-authentication/","text":"Token authentication What is token authentication? Token authentication means making a request to an API endpoint while also sending a special header that contains an access token. The access token was previously generated by (usually) the same API as the one you are sending requests to and it consists of an alphanumeric string. How does it work? In order to protect specific resources, clients need to be authenticated with user/admin roles. These roles are identified from the access token sent via the Authorization header. When DotKernel API receives a request, it tries to read the access token. If it does not find an access token, client has guest role: if the requested endpoint needs no authentication, the requested resource is returned else, a 403 Forbidden response is returned Else, client's account is identified and client has admin / user role (the one assigned in their account) if the requested endpoint is accessible to the client, the requested resource is returned else, a 403 Forbidden response is returned DotKernel API provides out-of-the-box both an admin and a user account. The admin account with role set to both superuser and admin with the following credentials: identity : admin password : dotkernel The user account with role set to both user and guest with the following credentials: identify : test@dotkernel.com password : dotkernel Flow client sends API request with credentials API returns a JSON object containing a new access and refresh token client sends API request using Authentication header containing the previously generated access token API returns requested resource Note The first two steps need to executed only once. Access token should be stored and reused for all upcoming requests. Refresh token should be stored and used to refresh expired access token. For a better overview of the flow, see the below image: Generate admin access token Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" } Note Replace &lt;identity&gt; with your admin account's identity and &lt;password&gt; with your admin account's password . Both fields come from table admin . Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"admin\", \"password\": \"dotkernel\" }' Generate user access token Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" } Note Replace &lt;identity&gt; with your user account's identity and &lt;password&gt; with your user account's password . Both fields come from table user . Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"test@dotkernel.com\", \"password\": \"dotkernel\" }' Response on success You should see a 200 OK response with the following JSON body: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.e...wuE39ON1mS5mnTKfA_dSpSWxOmNQdny_AKIbc1qZjMfS24qSUV8HIoOw\", \"refresh_token\": \"def502005a035c8dfe5456d27e85069813a4f8...0b844e843cd62865662a0e723165752dfd7012491502d3d819c2a61d\" } Field description: token_type : token type to be set when sending the Authorization header (example: Authorization: Bearer eyJ0e... ) expires_in : access token lifetime (modify in: config/autoload/local.php &gt; authentication . access_token_expire ) access_token : generated access token (store it for later use) refresh_token : generated refresh token (store it for regenerating expired access token) Response on failure You should see a 400 Bad Request response with the following JSON body: { \"error\": \"Invalid credentials.\", \"error_description\": \"Invalid credentials.\", \"message\": \"Invalid credentials.\" } Refresh admin access token Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" } Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/refresh-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"refresh_token\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }' Note Make sure you replace &lt;refresh-token&gt; with the refresh token generated with the access token. Refresh user access token Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" } Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/refresh-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }' Note Make sure you replace &lt;refresh-token&gt; with the refresh token generated with the access token. Response on success You should see a 200 OK response with the following JSON body: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.e...wuE39ON1mS5mnTKfA_dSpSWxOmNQdny_AKIbc1qZjMfS24qSUV8HIoOw\", \"refresh_token\": \"def502005a035c8dfe5456d27e85069813a4f8...0b844e843cd62865662a0e723165752dfd7012491502d3d819c2a61d\" } Field description: token_type : token type to be set when sending the Authorization header (example: Authorization: Bearer eyJ0e... ) expires_in : access token lifetime (change here: config/autoload/local.php authentication -&gt; access_token_expire ) access_token : generated access token (store it for later use) refresh_token : generated refresh token (store it for regenerating expired access token) Response on failure You should see a 401 Unauthorized response with the following JSON body: { \"error\": \"invalid_request\", \"error_description\": \"The refresh token is invalid.\", \"hint\": \"Cannot decrypt the refresh token\", \"message\": \"The refresh token is invalid.\" } Test admin authentication flow Step 1: Fail to fetch protected API content Try to view your admin account by executing: curl --location 'https://api.dotkernel.net/admin/my-account' You should get a 403 Forbidden JSON response. Step 2: Generate access token Generate admin access token by executing: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"admin\", \"password\": \"dotkernel\" }' You should get a 200 OK JSON response. Store the value of access_token for later use. Step 3: Successfully fetch protected API content Try again viewing your admin account by executing: curl --location 'https://api.dotkernel.net/admin/my-account' \\ --header 'Authorization: Bearer &lt;access_token&gt;' Replace &lt;access_token&gt; with the previously stored access token. You should get a 200 OK JSON response with the requested resource in the body. Test user authentication flow Step 1: Fail to fetch protected API content Try to view your admin account by executing: curl --location 'https://api.dotkernel.net/user/my-account' You should get a 403 Forbidden JSON response. Step 2: Generate access token Generate admin access token by executing: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"test@dotkernel.com\", \"password\": \"dotkernel\" }' You should get a 200 OK JSON response. Store the value of access_token for later use. Step 3: Successfully fetch protected API content Try again viewing your admin account by executing: curl --location 'https://api.dotkernel.net/user/my-account' \\ --header 'Authorization: Bearer &lt;access_token&gt;' Replace &lt;access_token&gt; with the previously stored access token. You should get a 200 OK JSON response with the requested resource in the body.","title":"Token authentication"},{"location":"v4/tutorials/token-authentication/#token-authentication","text":"","title":"Token authentication"},{"location":"v4/tutorials/token-authentication/#what-is-token-authentication","text":"Token authentication means making a request to an API endpoint while also sending a special header that contains an access token. The access token was previously generated by (usually) the same API as the one you are sending requests to and it consists of an alphanumeric string.","title":"What is token authentication?"},{"location":"v4/tutorials/token-authentication/#how-does-it-work","text":"In order to protect specific resources, clients need to be authenticated with user/admin roles. These roles are identified from the access token sent via the Authorization header. When DotKernel API receives a request, it tries to read the access token. If it does not find an access token, client has guest role: if the requested endpoint needs no authentication, the requested resource is returned else, a 403 Forbidden response is returned Else, client's account is identified and client has admin / user role (the one assigned in their account) if the requested endpoint is accessible to the client, the requested resource is returned else, a 403 Forbidden response is returned DotKernel API provides out-of-the-box both an admin and a user account. The admin account with role set to both superuser and admin with the following credentials: identity : admin password : dotkernel The user account with role set to both user and guest with the following credentials: identify : test@dotkernel.com password : dotkernel","title":"How does it work?"},{"location":"v4/tutorials/token-authentication/#flow","text":"client sends API request with credentials API returns a JSON object containing a new access and refresh token client sends API request using Authentication header containing the previously generated access token API returns requested resource","title":"Flow"},{"location":"v4/tutorials/token-authentication/#generate-admin-access-token","text":"Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" }","title":"Generate admin access token"},{"location":"v4/tutorials/token-authentication/#generate-user-access-token","text":"Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" }","title":"Generate user access token"},{"location":"v4/tutorials/token-authentication/#refresh-admin-access-token","text":"Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }","title":"Refresh admin access token"},{"location":"v4/tutorials/token-authentication/#refresh-user-access-token","text":"Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }","title":"Refresh user access token"},{"location":"v4/tutorials/token-authentication/#test-admin-authentication-flow","text":"","title":"Test admin authentication flow"},{"location":"v4/tutorials/token-authentication/#test-user-authentication-flow","text":"","title":"Test user authentication flow"},{"location":"v5/commands/create-admin-account/","text":"Creating admin accounts in DotKernel API Usage Run the following command in your application’s root directory: php ./bin/cli.php admin:create -i {IDENTITY} -p {PASSWORD} -f {FIRST_NAME} -l {LAST_NAME} OR php ./bin/cli.php admin:create --identity {IDENTITY} --password {PASSWORD} --firstName {FIRST_NAME} --lastName {LAST_NAME} after replacing: {IDENTITY} with a valid username OR email address {PASSWORD} with a valid password {FIRST_NAME} and {LAST_NAME} with valid names NOTE: if the specified fields contain special characters, make sure you surround them with double quote signs this method does not allow specifying an admin role – newly created accounts will have role of admin If the submitted data is valid, the outputted response is: Admin account has been created. The new admin account is ready to use. You can get more help with this command by running: php ./bin/cli.php help admin:create","title":"Create admin account"},{"location":"v5/commands/create-admin-account/#creating-admin-accounts-in-dotkernel-api","text":"","title":"Creating admin accounts in DotKernel API"},{"location":"v5/commands/create-admin-account/#usage","text":"Run the following command in your application’s root directory: php ./bin/cli.php admin:create -i {IDENTITY} -p {PASSWORD} -f {FIRST_NAME} -l {LAST_NAME} OR php ./bin/cli.php admin:create --identity {IDENTITY} --password {PASSWORD} --firstName {FIRST_NAME} --lastName {LAST_NAME} after replacing: {IDENTITY} with a valid username OR email address {PASSWORD} with a valid password {FIRST_NAME} and {LAST_NAME} with valid names NOTE: if the specified fields contain special characters, make sure you surround them with double quote signs this method does not allow specifying an admin role – newly created accounts will have role of admin If the submitted data is valid, the outputted response is: Admin account has been created. The new admin account is ready to use. You can get more help with this command by running: php ./bin/cli.php help admin:create","title":"Usage"},{"location":"v5/commands/display-available-endpoints/","text":"Displaying DotKernel API endpoints using dot-cli Usage Run the following command in your application’s root directory: php ./bin/cli.php route:list The command runs through all routes and extracts endpoint information in realtime. The output should be similar to the following: +--------+---------------------------------+--------------------------------+ | Method | Name | Path | +--------+---------------------------------+--------------------------------+ | POST | account.activate.request | /account/activate | | PATCH | account.activate | /account/activate/{hash} | | PATCH | account.modify-password | /account/reset-password/{hash} | | POST | account.recover-identity | /account/recover-identity | | POST | account.register | /account/register | | POST | account.reset-password.request | /account/reset-password | | GET | account.reset-password.validate | /account/reset-password/{hash} | | POST | admin.create | /admin | | DELETE | admin.delete | /admin/{uuid} | | GET | admin.list | /admin | | PATCH | admin.my-account.update | /admin/my-account | | GET | admin.my-account.view | /admin/my-account | | GET | admin.role.list | /admin/role | | GET | admin.role.view | /admin/role/{uuid} | | PATCH | admin.update | /admin/{uuid} | | GET | admin.view | /admin/{uuid} | | POST | error.report | /error-report | | GET | home | / | | POST | security.generate-token | /security/generate-token | | POST | security.refresh-token | /security/refresh-token | | POST | user.activate | /user/{uuid}/activate | | POST | user.avatar.create | /user/{uuid}/avatar | | DELETE | user.avatar.delete | /user/{uuid}/avatar | | GET | user.avatar.view | /user/{uuid}/avatar | | POST | user.create | /user | | DELETE | user.delete | /user/{uuid} | | GET | user.list | /user | | DELETE | user.my-account.delete | /user/my-account | | PATCH | user.my-account.update | /user/my-account | | GET | user.my-account.view | /user/my-account | | POST | user.my-avatar.create | /user/my-avatar | | DELETE | user.my-avatar.delete | /user/my-avatar | | GET | user.my-avatar.view | /user/my-avatar | | GET | user.role.list | /user/role | | GET | user.role.view | /user/role/{uuid} | | PATCH | user.update | /user/{uuid} | | GET | user.view | /user/{uuid} | +--------+---------------------------------+--------------------------------+ Filtering results The following filters can be applied when displaying the routes list: Filter routes by name, using: -i|--name[=NAME] Filter routes by path, using: -p|--path[=PATH] Filter routes by method, using: -m|--method[=METHOD] The filters are case-insensitive and can be combined. Get more help by running this command: php ./bin/cli.php route:list --help","title":"Display available endpoints"},{"location":"v5/commands/display-available-endpoints/#displaying-dotkernel-api-endpoints-using-dot-cli","text":"","title":"Displaying DotKernel API endpoints using dot-cli"},{"location":"v5/commands/display-available-endpoints/#usage","text":"Run the following command in your application’s root directory: php ./bin/cli.php route:list The command runs through all routes and extracts endpoint information in realtime. The output should be similar to the following: +--------+---------------------------------+--------------------------------+ | Method | Name | Path | +--------+---------------------------------+--------------------------------+ | POST | account.activate.request | /account/activate | | PATCH | account.activate | /account/activate/{hash} | | PATCH | account.modify-password | /account/reset-password/{hash} | | POST | account.recover-identity | /account/recover-identity | | POST | account.register | /account/register | | POST | account.reset-password.request | /account/reset-password | | GET | account.reset-password.validate | /account/reset-password/{hash} | | POST | admin.create | /admin | | DELETE | admin.delete | /admin/{uuid} | | GET | admin.list | /admin | | PATCH | admin.my-account.update | /admin/my-account | | GET | admin.my-account.view | /admin/my-account | | GET | admin.role.list | /admin/role | | GET | admin.role.view | /admin/role/{uuid} | | PATCH | admin.update | /admin/{uuid} | | GET | admin.view | /admin/{uuid} | | POST | error.report | /error-report | | GET | home | / | | POST | security.generate-token | /security/generate-token | | POST | security.refresh-token | /security/refresh-token | | POST | user.activate | /user/{uuid}/activate | | POST | user.avatar.create | /user/{uuid}/avatar | | DELETE | user.avatar.delete | /user/{uuid}/avatar | | GET | user.avatar.view | /user/{uuid}/avatar | | POST | user.create | /user | | DELETE | user.delete | /user/{uuid} | | GET | user.list | /user | | DELETE | user.my-account.delete | /user/my-account | | PATCH | user.my-account.update | /user/my-account | | GET | user.my-account.view | /user/my-account | | POST | user.my-avatar.create | /user/my-avatar | | DELETE | user.my-avatar.delete | /user/my-avatar | | GET | user.my-avatar.view | /user/my-avatar | | GET | user.role.list | /user/role | | GET | user.role.view | /user/role/{uuid} | | PATCH | user.update | /user/{uuid} | | GET | user.view | /user/{uuid} | +--------+---------------------------------+--------------------------------+","title":"Usage"},{"location":"v5/commands/display-available-endpoints/#filtering-results","text":"The following filters can be applied when displaying the routes list: Filter routes by name, using: -i|--name[=NAME] Filter routes by path, using: -p|--path[=PATH] Filter routes by method, using: -m|--method[=METHOD] The filters are case-insensitive and can be combined. Get more help by running this command: php ./bin/cli.php route:list --help","title":"Filtering results"},{"location":"v5/commands/generate-database-migrations/","text":"Generate a database migration without dropping custom tables Usage Run the following command in your application’s root directory: vendor/bin/doctrine-migrations diff If you have mapping modifications, this will create a new migration file under data/doctrine/migrations/ directory. Opening the migration file, you will notice that it contains some queries that will drop your oauth_* tables because they are unmapped (there is no doctrine entity describing them). You should delete your latest migration with the DROP queries in it as we will create another one, without the DROP queries in it. In order to avoid dropping these tables, you need to add a parameter called filter-expression . The command to be executed without dropping these tables looks like this: On Windows (use double quotes): vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!oauth_)/\" On Linux/macOS (use single quotes): vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' Filtering multiple unmapped table patterns If your database contains multiple unmapped table groups, then the pattern in filter-expression should hold all table prefixes concatenated by pipe character ( | ). For example, if you need to filter tables prefixed with foo_ and bar_ , then the command should look like this: On Windows: vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!foo_|bar_)/\" On Linux/macOS: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!foo_|bar_)/' Troubleshooting On Windows, running the command in PowerShell might still add the DROP TABLE oauth_* queries to the migration file. This happens because for PowerShell the caret ( ^ ) is a special character, so it gets dropped ( \"/^(?!oauth_)/\" becomes \"/(?!oauth_)/\" when it reaches your command). Escaping it will not help either. In this case, we recommend running the command: directly from your IDE using Linux shell from the Command Prompt Help You can get more help with this command by running: vendor/bin/doctrine-migrations help diff","title":"Generate database migrations"},{"location":"v5/commands/generate-database-migrations/#generate-a-database-migration-without-dropping-custom-tables","text":"","title":"Generate a database migration without dropping custom tables"},{"location":"v5/commands/generate-database-migrations/#usage","text":"Run the following command in your application’s root directory: vendor/bin/doctrine-migrations diff If you have mapping modifications, this will create a new migration file under data/doctrine/migrations/ directory. Opening the migration file, you will notice that it contains some queries that will drop your oauth_* tables because they are unmapped (there is no doctrine entity describing them). You should delete your latest migration with the DROP queries in it as we will create another one, without the DROP queries in it. In order to avoid dropping these tables, you need to add a parameter called filter-expression . The command to be executed without dropping these tables looks like this: On Windows (use double quotes): vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!oauth_)/\" On Linux/macOS (use single quotes): vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/'","title":"Usage"},{"location":"v5/commands/generate-database-migrations/#filtering-multiple-unmapped-table-patterns","text":"If your database contains multiple unmapped table groups, then the pattern in filter-expression should hold all table prefixes concatenated by pipe character ( | ). For example, if you need to filter tables prefixed with foo_ and bar_ , then the command should look like this: On Windows: vendor/bin/doctrine-migrations diff --filter-expression=\"/^(?!foo_|bar_)/\" On Linux/macOS: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!foo_|bar_)/'","title":"Filtering multiple unmapped table patterns"},{"location":"v5/commands/generate-database-migrations/#troubleshooting","text":"On Windows, running the command in PowerShell might still add the DROP TABLE oauth_* queries to the migration file. This happens because for PowerShell the caret ( ^ ) is a special character, so it gets dropped ( \"/^(?!oauth_)/\" becomes \"/(?!oauth_)/\" when it reaches your command). Escaping it will not help either. In this case, we recommend running the command: directly from your IDE using Linux shell from the Command Prompt","title":"Troubleshooting"},{"location":"v5/commands/generate-database-migrations/#help","text":"You can get more help with this command by running: vendor/bin/doctrine-migrations help diff","title":"Help"},{"location":"v5/commands/generate-tokens/","text":"Generating tokens in DotKernel API This is a multipurpose command that allows creating tokens required by different parts of the API. Usage Go to your application's root directory. Run the token generator command by executing the following command: php ./bin/cli.php token:generate &lt;type&gt; Where &lt;type&gt; is one of the following: error-reporting If you need help using the command, execute the following command: php ./bin/cli.php token:generate --help Generate error reporting token You can generate an error reporting token by executing the following command: php ./bin/cli.php token:generate error-reporting The output should look similar to this: Error reporting token: 0123456789abcdef0123456789abcdef01234567 Copy the generated token. Open config/autoload/error-handling.global.php and paste the copied token as shown below: return [ ... ErrorReportServiceInterface::class =&gt; [ ... 'tokens' =&gt; [ '0123456789abcdef0123456789abcdef01234567', ], ... ] ] Save and close config/autoload/error-handling.global.php . Note : If your application is NOT in development mode, make sure you clear your config cache by executing: php ./bin/clear-config-cache.php","title":"Generate tokens"},{"location":"v5/commands/generate-tokens/#generating-tokens-in-dotkernel-api","text":"This is a multipurpose command that allows creating tokens required by different parts of the API.","title":"Generating tokens in DotKernel API"},{"location":"v5/commands/generate-tokens/#usage","text":"Go to your application's root directory. Run the token generator command by executing the following command: php ./bin/cli.php token:generate &lt;type&gt; Where &lt;type&gt; is one of the following: error-reporting If you need help using the command, execute the following command: php ./bin/cli.php token:generate --help","title":"Usage"},{"location":"v5/core-features/authentication/","text":"Authentication Authentication is the process by which an identity is presented to the application. It ensures that the entity making the request has the proper credentials to access the API. DotKernel API identities are delivered to the application from the client through the Authorization request. If it is present, the application tries to find and assign the identity to the application. If it is not presented, DotKernel API assigns a default guest identity, represented by an instance of the class Mezzio\\Authentication\\UserInterface . Configuration Authentication in DotKernel API is built around the mezzio/mezzio-authentication-oauth2 component and is already configured out of the box. But if you want to dig more, the configuration is stored in config/autoload/local.php under the authentication key. You can check the mezzio/mezzio-authentication-oauth2 configuration part for more info. How it works DotKernels API authentication system can be used for SPAs (single-page applications), mobile applications, and simple, token-based APIs. It allows each user of your application to generate API tokens for their accounts. The authentication happens through the middleware in the Api\\App\\Middleware\\AuthenticationMiddleware . Database When you install DotKernel API for the first time, you need to run the migrations and seeders. All the tables required for authentication are automatically created and populated. In DotKernel API, authenticated users come from either the admin or the user table. We choose to keep the admin table separated from the users to prevent users of the application from accessing sensitive data, which only the administrators of the application should access. The oauth_clients table is pre-populated with the default admin and frontend clients with the same password as their names ( we recommend you change the default passwords ). As you guessed each client serves to authenticate admin or user . Another table that is pre-populated is the oauth_scopes table, with the api scope. Issuing API Tokens Token generation in DotKernel API is done using the password grand_type scenario, which in this case allows authentication to an API using the user's credentials (generally a username and password). The client sends a POST request to the /security/generate-token with the following parameters: grant_type = password. client_id = column name from the oauth_clients table client_secret = column secret from the oauth_clients table scope = column scope from the oauth_scopes table username = column identity from table admin / user password = column password from table admin / user POST /security/generate-token HTTP/1.1 Accept: application/json Content-Type: application/json { \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"test@dotkernel.com\", \"password\": \"dotkernel\" } The server responds with a JSON as follows: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...\", \"refresh_token\": \"def5020087199939a49d0f2f818...\" } Next time when you make a request to the server to an authenticated endpoint, the client should use the Authorization header request. GET /users/1 HTTP/1.1 Accept: application/json Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9... Refreshing tokens DotKernel API can refresh the access token, based on the expired access token's refresh_token . The clients need to send a POST request to the /security/refresh-token with the following request POST /security/refresh-token HTTP/1.1 Accept: application/json Content-Type: application/json { \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\" : \"def5020087199939a49d0f2f818...\" } The server responds with a JSON as follows: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9...\", \"refresh_token\": \"def5020087199939a49d0f2f818...\" }","title":"Authentication"},{"location":"v5/core-features/authentication/#authentication","text":"Authentication is the process by which an identity is presented to the application. It ensures that the entity making the request has the proper credentials to access the API. DotKernel API identities are delivered to the application from the client through the Authorization request. If it is present, the application tries to find and assign the identity to the application. If it is not presented, DotKernel API assigns a default guest identity, represented by an instance of the class Mezzio\\Authentication\\UserInterface .","title":"Authentication"},{"location":"v5/core-features/authentication/#configuration","text":"Authentication in DotKernel API is built around the mezzio/mezzio-authentication-oauth2 component and is already configured out of the box. But if you want to dig more, the configuration is stored in config/autoload/local.php under the authentication key. You can check the mezzio/mezzio-authentication-oauth2 configuration part for more info.","title":"Configuration"},{"location":"v5/core-features/authentication/#how-it-works","text":"DotKernels API authentication system can be used for SPAs (single-page applications), mobile applications, and simple, token-based APIs. It allows each user of your application to generate API tokens for their accounts. The authentication happens through the middleware in the Api\\App\\Middleware\\AuthenticationMiddleware .","title":"How it works"},{"location":"v5/core-features/authentication/#database","text":"When you install DotKernel API for the first time, you need to run the migrations and seeders. All the tables required for authentication are automatically created and populated. In DotKernel API, authenticated users come from either the admin or the user table. We choose to keep the admin table separated from the users to prevent users of the application from accessing sensitive data, which only the administrators of the application should access. The oauth_clients table is pre-populated with the default admin and frontend clients with the same password as their names ( we recommend you change the default passwords ). As you guessed each client serves to authenticate admin or user . Another table that is pre-populated is the oauth_scopes table, with the api scope.","title":"Database"},{"location":"v5/core-features/authorization/","text":"Authorization Authorization is the process by which a system takes a validated identity and checks if that identity has access to a given resource. DotKernel API 's implementation of authorization uses Mezzio\\Authorization\\Rbac\\LaminasRbac as a model of Role-Based Access Control (RBAC). How it works In DotKernel API each authenticatable entity (admin/user) comes with their roles table where you can define roles for each entity. RBAC comes in to ensure that each entity has the appropriate role and permission to access a resource. The authorization happens through the Api\\App\\Middleware\\AuthorizationMiddleware middleware. Configuration DotKernel API makes use of mezzio-authorization-rbac and includes the full configuration. The configuration file for the role and permission definitions is config/autoload/authorization.global.php . 'mezzio-authorization-rbac' =&gt; [ 'roles' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ AdminRole::ROLE_SUPERUSER, ], UserRole::ROLE_GUEST =&gt; [ UserRole::ROLE_USER, ], ], 'permissions' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ 'other.routes' 'admin.list', 'home' ], UserRole::ROLE_USER =&gt; [ 'other.routes', 'user.my-account.update', 'user.my-account.view', ], UserRole::ROLE_GUEST =&gt; [ 'other.routes', 'security.refresh-token', 'error.report', 'home', ], ], ], See mezzio-authorization-rbac for more information. Usage Based on the configuration file above, we have 2 admins roles ( superuser , admin ) and 2 users roles ( user , guest ). Roles inherit the permissions from their parents: superuser has no parent admin has superuser as a parent which means superuser also has admin permissions user has no parent guest has user as a parent which means user also has guest permissions For each role we defined an array of permissions. A permission in DotKernel API is basically a route name. As you can see, the superuser does not have its own permissions, because it gains all the permissions from admin , no need to define explicit permissions. The user role, gains all the permission from guest so no need to define that user can access home route, but guest cannot access user-specific routes.","title":"Authorization"},{"location":"v5/core-features/authorization/#authorization","text":"Authorization is the process by which a system takes a validated identity and checks if that identity has access to a given resource. DotKernel API 's implementation of authorization uses Mezzio\\Authorization\\Rbac\\LaminasRbac as a model of Role-Based Access Control (RBAC).","title":"Authorization"},{"location":"v5/core-features/authorization/#how-it-works","text":"In DotKernel API each authenticatable entity (admin/user) comes with their roles table where you can define roles for each entity. RBAC comes in to ensure that each entity has the appropriate role and permission to access a resource. The authorization happens through the Api\\App\\Middleware\\AuthorizationMiddleware middleware.","title":"How it works"},{"location":"v5/core-features/authorization/#configuration","text":"DotKernel API makes use of mezzio-authorization-rbac and includes the full configuration. The configuration file for the role and permission definitions is config/autoload/authorization.global.php . 'mezzio-authorization-rbac' =&gt; [ 'roles' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ AdminRole::ROLE_SUPERUSER, ], UserRole::ROLE_GUEST =&gt; [ UserRole::ROLE_USER, ], ], 'permissions' =&gt; [ AdminRole::ROLE_SUPERUSER =&gt; [], AdminRole::ROLE_ADMIN =&gt; [ 'other.routes' 'admin.list', 'home' ], UserRole::ROLE_USER =&gt; [ 'other.routes', 'user.my-account.update', 'user.my-account.view', ], UserRole::ROLE_GUEST =&gt; [ 'other.routes', 'security.refresh-token', 'error.report', 'home', ], ], ], See mezzio-authorization-rbac for more information.","title":"Configuration"},{"location":"v5/core-features/authorization/#usage","text":"Based on the configuration file above, we have 2 admins roles ( superuser , admin ) and 2 users roles ( user , guest ). Roles inherit the permissions from their parents: superuser has no parent admin has superuser as a parent which means superuser also has admin permissions user has no parent guest has user as a parent which means user also has guest permissions For each role we defined an array of permissions. A permission in DotKernel API is basically a route name. As you can see, the superuser does not have its own permissions, because it gains all the permissions from admin , no need to define explicit permissions. The user role, gains all the permission from guest so no need to define that user can access home route, but guest cannot access user-specific routes.","title":"Usage"},{"location":"v5/core-features/content-validation/","text":"Content Negotiation Content Negotiation is performed by an application in order : To match the requested representation as specified by the client via the Accept header with a representation the application can deliver. To determine the Content-Type of incoming data and deserialize it so the application can utilize it. Essentially, content negotiation is the client telling the server what it is sending and what it wants in return, and the server determining if it can do what the client requests. Content negotiation validation in DotKernel API happens through middleware, and it ensures that the incoming request and the outgoing response conform to the content types specified in the config file for all routes or for a specific route. It performs validation on the Accept and Content-Type headers of the request and response and returning appropriate errors responses when necessary. Configuration In DotKernel API the configuration file for content negotiation is held in config/autoload/content-negotiation.global.php and the array looks like this: return [ 'content-negotiation' =&gt; [ 'default' =&gt; [ 'Accept' =&gt; [ 'application/json', 'application/hal+json', ], 'Content-Type' =&gt; [ 'application/json', 'application/hal+json', ], ], 'your.route.name' =&gt; [ 'Accept' =&gt; [], 'Content-Type' =&gt; [], ], ], ]; Except the default key, all your keys must match the route name, for example in DotKernel API we have the route to list all admins, which name is admin.list . If you did not specify a route name to configure your specifications about content negotiation, the default one will be in place. The default key is mandatory . Every route configuration must come with Accept and Content-Type keys, basically this will be the keys that the request headers will be validated against. Accept Negotiation This specifies that your server can return that representation, or at least one of the representation sent by the client. GET /admin HTTP/1.1 Accept: application/json This request indicates the client wants application/json in return. Now the server, through the config file will try to validate if that representation can be returned, basically if application/json is presented in the Accept key. If the representation cannot be returned, a status code 406 - Not Acceptable will be returned. If the representation can be returned, the server should report the media type through Content-Type header of the response. Due to how these validations are made, for a json media type, the server can return a more generic media type, for example, if the clients send Accept: application/vnd.api+json and you configured your Accept key as application/json the representation will still be returned as json . If the Accept header of the request contains */* it means that whatever the server can return it is OK, so it can return anything. Content-Type Negotiation The second aspect of content negotiation is the Content-Type header and determine the server can deserialize the data. POST /admin/1 HTTP/1.1 Accept: application/json Content-Type: application/json { \"foo\": \"bar\" } The server will try to validate the Content-Type header against your configured Content-Type key from the config file, and if the format is not supported, a status code 415 - Unsupported Media Type will be returned. For example, if you have a route that needs a file to be uploaded , normally you will configure the Content-Type of that route to be multipart/form-data . The above request will fail as the client send application/json as Content-Type . If the request does not contain \"Content-Type\" header, that means that the server will try to deserialize the data as it can. The Request &lt;-&gt; Response validation In addition to the validation described above, a third one is happening and is the last one: the server will check if the request Accept header can really be returned by the response. Through the way DotKernel API is returning a response in handler, a content type is always set. This cannot be the case in any custom response but in any case the server will check what Content-Type the response is returning and will try to validate that against the Accept header of the request. If the validation fails, a status code 406 - Not Acceptable will be returned.","title":"Content Validation"},{"location":"v5/core-features/content-validation/#content-negotiation","text":"Content Negotiation is performed by an application in order : To match the requested representation as specified by the client via the Accept header with a representation the application can deliver. To determine the Content-Type of incoming data and deserialize it so the application can utilize it. Essentially, content negotiation is the client telling the server what it is sending and what it wants in return, and the server determining if it can do what the client requests. Content negotiation validation in DotKernel API happens through middleware, and it ensures that the incoming request and the outgoing response conform to the content types specified in the config file for all routes or for a specific route. It performs validation on the Accept and Content-Type headers of the request and response and returning appropriate errors responses when necessary.","title":"Content Negotiation"},{"location":"v5/core-features/content-validation/#configuration","text":"In DotKernel API the configuration file for content negotiation is held in config/autoload/content-negotiation.global.php and the array looks like this: return [ 'content-negotiation' =&gt; [ 'default' =&gt; [ 'Accept' =&gt; [ 'application/json', 'application/hal+json', ], 'Content-Type' =&gt; [ 'application/json', 'application/hal+json', ], ], 'your.route.name' =&gt; [ 'Accept' =&gt; [], 'Content-Type' =&gt; [], ], ], ]; Except the default key, all your keys must match the route name, for example in DotKernel API we have the route to list all admins, which name is admin.list . If you did not specify a route name to configure your specifications about content negotiation, the default one will be in place. The default key is mandatory . Every route configuration must come with Accept and Content-Type keys, basically this will be the keys that the request headers will be validated against.","title":"Configuration"},{"location":"v5/core-features/content-validation/#accept-negotiation","text":"This specifies that your server can return that representation, or at least one of the representation sent by the client. GET /admin HTTP/1.1 Accept: application/json This request indicates the client wants application/json in return. Now the server, through the config file will try to validate if that representation can be returned, basically if application/json is presented in the Accept key. If the representation cannot be returned, a status code 406 - Not Acceptable will be returned. If the representation can be returned, the server should report the media type through Content-Type header of the response. Due to how these validations are made, for a json media type, the server can return a more generic media type, for example, if the clients send Accept: application/vnd.api+json and you configured your Accept key as application/json the representation will still be returned as json . If the Accept header of the request contains */* it means that whatever the server can return it is OK, so it can return anything.","title":"Accept Negotiation"},{"location":"v5/core-features/content-validation/#content-type-negotiation","text":"The second aspect of content negotiation is the Content-Type header and determine the server can deserialize the data. POST /admin/1 HTTP/1.1 Accept: application/json Content-Type: application/json { \"foo\": \"bar\" } The server will try to validate the Content-Type header against your configured Content-Type key from the config file, and if the format is not supported, a status code 415 - Unsupported Media Type will be returned. For example, if you have a route that needs a file to be uploaded , normally you will configure the Content-Type of that route to be multipart/form-data . The above request will fail as the client send application/json as Content-Type . If the request does not contain \"Content-Type\" header, that means that the server will try to deserialize the data as it can.","title":"Content-Type Negotiation"},{"location":"v5/core-features/content-validation/#the-request-response-validation","text":"In addition to the validation described above, a third one is happening and is the last one: the server will check if the request Accept header can really be returned by the response. Through the way DotKernel API is returning a response in handler, a content type is always set. This cannot be the case in any custom response but in any case the server will check what Content-Type the response is returning and will try to validate that against the Accept header of the request. If the validation fails, a status code 406 - Not Acceptable will be returned.","title":"The Request &lt;-&gt; Response validation"},{"location":"v5/core-features/cors/","text":"CORS What is CORS? Cross-Origin Resource Sharing or CORS is an HTTP-header based mechanism that allows a server to indicate any other origins (domain, scheme, or port) than its own from which a browser should permit loading of resources. Why do we need CORS? When integrating an API, most developers have encountered the following error message: Access to fetch at RESOURCE_URL from origin ORIGIN_URL has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. This happens because the API ( RESOURCE_URL ) is not configured to accept requests from the client ( ORIGIN_URL ). How to fix? DotKernel API fixes this issue using the mezzio/mezzio-cors library. Step 1: Install library In order to install mezzio/mezzio-cors , run the following command: composer require mezzio/mezzio-cors Step 2: Configure your API Register ConfigProvider Register mezzio/mezzio-cors in your application by adding its ConfigProvider to your application's config aggregator. Open the file config/config.php and paste the below lines at the beginning of the array passed to ConfigAggregator : Laminas\\Diactoros\\ConfigProvider::class, Mezzio\\Cors\\ConfigProvider::class, Save and close the file. Add middleware Add mezzio/mezzio-cors middleware to your application's pipeline. Open config/pipeline.php and paste the below line before the one with RouteMiddleware::class : $app-&gt;pipe(\\Mezzio\\Cors\\Middleware\\CorsMiddleware::class); Save and close the file. Create config file Create and open file config/autoload/cors.local.php and add the following code inside it: &lt;?php declare(strict_types=1); use Mezzio\\Cors\\Configuration\\ConfigurationInterface; return [ ConfigurationInterface::CONFIGURATION_IDENTIFIER =&gt; [ 'allowed_origins' =&gt; [ ConfigurationInterface::ANY_ORIGIN, ], 'allowed_headers' =&gt; ['Accept', 'Content-Type', 'Authorization'], 'allowed_max_age' =&gt; '600', 'credentials_allowed' =&gt; true, 'exposed_headers' =&gt; [], ], ]; This list explains the above configuration values: allowed_origins : an array of domains that are allowed to interact with the API (default ConfigurationInterface::ANY_ORIGIN which means that any domain can make requests to the API) allowed_headers : an array of allowed custom headers allowed_max_age : the maximum duration, since the preflight response may be cached by a client credentials_allowed : allows a request to pass cookies exposed_headers : an array of headers which are being exposed by the endpoint Save and close the file. On the production environment, make sure you allow only specific origins by adding them to the allowed_origins array and removing the current value of ConfigurationInterface::ANY_ORIGIN . For more info, see mezzio/mezzio-cors documentation .","title":"CORS"},{"location":"v5/core-features/cors/#cors","text":"","title":"CORS"},{"location":"v5/core-features/cors/#what-is-cors","text":"Cross-Origin Resource Sharing or CORS is an HTTP-header based mechanism that allows a server to indicate any other origins (domain, scheme, or port) than its own from which a browser should permit loading of resources.","title":"What is CORS?"},{"location":"v5/core-features/cors/#why-do-we-need-cors","text":"When integrating an API, most developers have encountered the following error message: Access to fetch at RESOURCE_URL from origin ORIGIN_URL has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. This happens because the API ( RESOURCE_URL ) is not configured to accept requests from the client ( ORIGIN_URL ).","title":"Why do we need CORS?"},{"location":"v5/core-features/cors/#how-to-fix","text":"DotKernel API fixes this issue using the mezzio/mezzio-cors library.","title":"How to fix?"},{"location":"v5/core-features/dependency-injection/","text":"Dependency Injection Dependency injection is a design pattern used in software development to implement inversion of control. In simpler terms, it's the act of providing dependencies for an object during instantiation. In PHP, dependency injection can be implemented in various ways, including through constructor injection, setter injection and property injection. DotKernel API, through its dot-dependency-injection package focuses only on constructor injection. Usage DotKernel API comes out of the box with the dot-dependency-injection package, which provides all we need for injecting dependencies into any object you want. dot-dependency-injection determines the dependencies by looking at the #[Inject] attribute, added to the constructor of a class. Dependencies are specified as separate parameters of the #[Inject] attribute. For our example we will inject UserService and config dependencies into a UseHandler . use Dot\\DependencyInjection\\Attribute\\Inject; class UserHandler implements RequestHandlerInterface { #[Inject( UserService::class, \"config\", )] public function __construct( protected UserServiceInterface $userService, protected array $config, ) { } } If your class needs the value of a specific configuration key, you can specify the path using dot notation: config.example The next step is to register the class in the ConfigProvider under factories using Dot\\DependencyInjection\\Factory\\AttributedServiceFactory::class public function getDependencies(): array { return [ 'factories' =&gt; [ UserHandler::class =&gt; AttributedServiceFactory::class ] ]; } That's it. When your object is instantiated from the container, it will automatically have its dependencies resolved. Dependencies injection is available to any object within DotKernel API. For example, you can inject dependencies in a service, a handler and so on, simply by registering it in the ConfigProvider .","title":"Dependency Injection"},{"location":"v5/core-features/dependency-injection/#dependency-injection","text":"Dependency injection is a design pattern used in software development to implement inversion of control. In simpler terms, it's the act of providing dependencies for an object during instantiation. In PHP, dependency injection can be implemented in various ways, including through constructor injection, setter injection and property injection. DotKernel API, through its dot-dependency-injection package focuses only on constructor injection.","title":"Dependency Injection"},{"location":"v5/core-features/dependency-injection/#usage","text":"DotKernel API comes out of the box with the dot-dependency-injection package, which provides all we need for injecting dependencies into any object you want. dot-dependency-injection determines the dependencies by looking at the #[Inject] attribute, added to the constructor of a class. Dependencies are specified as separate parameters of the #[Inject] attribute. For our example we will inject UserService and config dependencies into a UseHandler . use Dot\\DependencyInjection\\Attribute\\Inject; class UserHandler implements RequestHandlerInterface { #[Inject( UserService::class, \"config\", )] public function __construct( protected UserServiceInterface $userService, protected array $config, ) { } } If your class needs the value of a specific configuration key, you can specify the path using dot notation: config.example The next step is to register the class in the ConfigProvider under factories using Dot\\DependencyInjection\\Factory\\AttributedServiceFactory::class public function getDependencies(): array { return [ 'factories' =&gt; [ UserHandler::class =&gt; AttributedServiceFactory::class ] ]; } That's it. When your object is instantiated from the container, it will automatically have its dependencies resolved. Dependencies injection is available to any object within DotKernel API. For example, you can inject dependencies in a service, a handler and so on, simply by registering it in the ConfigProvider .","title":"Usage"},{"location":"v5/core-features/exceptions/","text":"Exceptions What are exceptions? Exceptions are a powerful mechanism for handling errors and other exceptional conditions that may occur during the execution of a script. They provide a way to manage errors in a structured and controlled manner, separating error-handling code from regular code. How we use exceptions? When it comes to handling exceptions, DotKernel API relies on the usage of easy-to-understand, problem-specific exceptions. Out-of-the-box we provide the following custom exceptions: BadRequestException thrown when client tries to create/update resource, but the data from the request is invalid/incomplete (example: client tries to create an account, but does not send the required identity field) ConflictException thrown when resource cannot be created because a different resource with the same identifier already exists (example: cannot change existing user's identity because another user with the same identity already exists) resource cannot change its state because it is already in the specified state (example: user cannot be activated because it is already active) ExpiredException thrown when resource cannot be accessed because it expired (example: account activation link) resource cannot be accessed because it has been consumed (example: one-time password) ForbiddenException thrown when resource cannot be accessed by the authenticated client (example: client authenticated as regular user sends a GET /admin request) MethodNotAllowedException thrown when client tries to interact with a resource via an invalid HTTP request method (example: client sends a PATCH /avatar request) NotFoundException thrown when client tries to interact with a resource that does not exist on the server (example: client sends a GET /resource-does-not-exist request) UnauthorizedException thrown when resource cannot be accessed because the client is not authenticated (example: unauthenticated client sends a GET /admin request) How it works? During a request, if there is no uncaught exception DotKernel API will return a JSON response with the data provided by the handler that handled the request. Else, it will build and send a response based on the exception thrown: BadRequestException will return a 400 Bad Request response UnauthorizedException will return a 401 Unauthorized response ForbiddenException will return a 403 Forbidden response OutOfBoundsException and NotFoundException will return a 404 Not Found response MethodNotAllowedException will return a 405 Method Not Allowed response ConflictException will return a 409 Conflict response ExpiredException will return a 410 Gone response MailException , RuntimeException and the generic Exception will return a 500 Internal Server Error response How to extend? In this example we will create a custom exception called CustomException , place it next to the already existing custom exceptions (you can use your preferred location) and finally return a custom HTTP status code when CustomException is encountered. Step 1: Create exception file Navigate to the directory src/App/src/Handler/Exception and create a PHP class called CustomException.php . Open CustomException.php and add the following content: &lt;?php declare(strict_types=1); namespace Api\\App\\Exception; use Exception; class CustomException extends Exception { } Save and close the file. Step 2: Use exception file Open the file src/App/src/Handler/HomeHandler.php and at the beginning of the get method, place the following code: throw new \\Api\\App\\Exception\\CustomException('some message'); Save and close the file. Step 3: Test for failure Access your API's home page URL and make sure it returns 500 Internal Server Error HTTP status code and the following content: { \"error\": { \"messages\": [ \"some message\" ] } } Step 4: Prepare for success Open the file src/App/src/Handler/HandlerTrait.php and locate the handle method. Insert the following lines of code before the first catch statement: } catch (\\Api\\App\\Exception\\CustomException $exception) { return $this-&gt;errorResponse($exception-&gt;getMessage(), StatusCodeInterface::STATUS_IM_A_TEAPOT); Save and close the file. Step 5: Test for success Again, access your API's home page URL, which should return the same content. Notice that this time it returns 418 I'm a teapot HTTP status code.","title":"Exceptions"},{"location":"v5/core-features/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"v5/core-features/exceptions/#what-are-exceptions","text":"Exceptions are a powerful mechanism for handling errors and other exceptional conditions that may occur during the execution of a script. They provide a way to manage errors in a structured and controlled manner, separating error-handling code from regular code.","title":"What are exceptions?"},{"location":"v5/core-features/exceptions/#how-we-use-exceptions","text":"When it comes to handling exceptions, DotKernel API relies on the usage of easy-to-understand, problem-specific exceptions. Out-of-the-box we provide the following custom exceptions:","title":"How we use exceptions?"},{"location":"v5/core-features/exceptions/#how-it-works","text":"During a request, if there is no uncaught exception DotKernel API will return a JSON response with the data provided by the handler that handled the request. Else, it will build and send a response based on the exception thrown: BadRequestException will return a 400 Bad Request response UnauthorizedException will return a 401 Unauthorized response ForbiddenException will return a 403 Forbidden response OutOfBoundsException and NotFoundException will return a 404 Not Found response MethodNotAllowedException will return a 405 Method Not Allowed response ConflictException will return a 409 Conflict response ExpiredException will return a 410 Gone response MailException , RuntimeException and the generic Exception will return a 500 Internal Server Error response","title":"How it works?"},{"location":"v5/core-features/exceptions/#how-to-extend","text":"In this example we will create a custom exception called CustomException , place it next to the already existing custom exceptions (you can use your preferred location) and finally return a custom HTTP status code when CustomException is encountered.","title":"How to extend?"},{"location":"v5/flow/default-library-flow/","text":"Default Library Flow The graph below demonstrates a default flow between DotKernel's libraries.","title":"Default Library Flow"},{"location":"v5/flow/default-library-flow/#default-library-flow","text":"The graph below demonstrates a default flow between DotKernel's libraries.","title":"Default Library Flow"},{"location":"v5/flow/library-flow-for-email/","text":"Library Flow for Email The graph below demonstrates the simplified flow between DotKernel's libraries for sending an email.","title":"Library Flow for Email"},{"location":"v5/flow/library-flow-for-email/#library-flow-for-email","text":"The graph below demonstrates the simplified flow between DotKernel's libraries for sending an email.","title":"Library Flow for Email"},{"location":"v5/flow/middleware-flow/","text":"Middleware flow The graph below demonstrates a default flow between DotKernel's middlewares.","title":"Middleware Flow"},{"location":"v5/flow/middleware-flow/#middleware-flow","text":"The graph below demonstrates a default flow between DotKernel's middlewares.","title":"Middleware flow"},{"location":"v5/installation/composer/","text":"Composer Installation of Packages Install dependencies composer install Development mode If you're installing the project for development, make sure you have development mode enabled, by running: composer development-enable You can disable development mode by running: composer development-disable You can check if you have development mode enabled by running: composer development-status","title":"Composer"},{"location":"v5/installation/composer/#composer-installation-of-packages","text":"","title":"Composer Installation of Packages"},{"location":"v5/installation/composer/#install-dependencies","text":"composer install","title":"Install dependencies"},{"location":"v5/installation/composer/#development-mode","text":"If you're installing the project for development, make sure you have development mode enabled, by running: composer development-enable You can disable development mode by running: composer development-disable You can check if you have development mode enabled by running: composer development-status","title":"Development mode"},{"location":"v5/installation/configuration-files/","text":"Configuration Files Prepare config files duplicate config/autoload/cors.local.php.dist as config/autoload/cors.local.php Note if your API will be consumed by another application, make sure to configure the allowed_origins variable duplicate config/autoload/local.php.dist as config/autoload/local.php duplicate config/autoload/mail.local.php.dist as config/autoload/mail.local.php Note if your API will send emails, make sure to fill in SMTP connection params optional : in order to run/create tests, duplicate config/autoload/local.test.php.dist as config/autoload/local.test.php Note this creates a new in-memory database that your tests will run on.","title":"Configuration Files"},{"location":"v5/installation/configuration-files/#configuration-files","text":"","title":"Configuration Files"},{"location":"v5/installation/configuration-files/#prepare-config-files","text":"duplicate config/autoload/cors.local.php.dist as config/autoload/cors.local.php","title":"Prepare config files"},{"location":"v5/installation/doctrine-orm/","text":"Doctrine ORM Setup database Make sure you fill out the database credentials in config/autoload/local.php under $databases['default'] . Create a new MySQL database - set collation to utf8mb4_general_ci Running migrations Run the database migrations by using the following command: php vendor/bin/doctrine-migrations migrate This command will prompt you to confirm that you want to run it. WARNING! You are about to execute a migration in database \"...\" that could result in schema changes and data loss. Are you sure you wish to continue? (yes/no) [yes]: Hit Enter to confirm the operation. Executing fixtures Fixtures are used to seed the database with initial values and should be executed after migrating the database. To list all the fixtures, run: php bin/doctrine fixtures:list This will output all the fixtures in the order of execution. To execute all fixtures, run: php bin/doctrine fixtures:execute To execute a specific fixture, run: php bin/doctrine fixtures:execute --class=FixtureClassName More details on how fixtures work can be found here: https://github.com/dotkernel/dot-data-fixtures#creating-fixtures","title":"Doctrine ORM"},{"location":"v5/installation/doctrine-orm/#doctrine-orm","text":"","title":"Doctrine ORM"},{"location":"v5/installation/doctrine-orm/#setup-database","text":"Make sure you fill out the database credentials in config/autoload/local.php under $databases['default'] . Create a new MySQL database - set collation to utf8mb4_general_ci","title":"Setup database"},{"location":"v5/installation/doctrine-orm/#running-migrations","text":"Run the database migrations by using the following command: php vendor/bin/doctrine-migrations migrate This command will prompt you to confirm that you want to run it. WARNING! You are about to execute a migration in database \"...\" that could result in schema changes and data loss. Are you sure you wish to continue? (yes/no) [yes]: Hit Enter to confirm the operation.","title":"Running migrations"},{"location":"v5/installation/doctrine-orm/#executing-fixtures","text":"Fixtures are used to seed the database with initial values and should be executed after migrating the database. To list all the fixtures, run: php bin/doctrine fixtures:list This will output all the fixtures in the order of execution. To execute all fixtures, run: php bin/doctrine fixtures:execute To execute a specific fixture, run: php bin/doctrine fixtures:execute --class=FixtureClassName More details on how fixtures work can be found here: https://github.com/dotkernel/dot-data-fixtures#creating-fixtures","title":"Executing fixtures"},{"location":"v5/installation/faq/","text":"Frequently Asked Questions How do I fix common permission issues? If running your project you encounter some permission issues, follow the below steps. Errors PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data\" is not writable... PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data/cache\" is not writable... PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data/cache/doctrine\" is not writable... Fix: chmod -R 777 data Error PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/public/uploads\" is not writable... Fix: chmod -R 777 public/uploads Error PHP Fatal error: Uncaught ErrorException: fopen(/var/www/ example.local /config/autoload/../../log/error-log- yyyy-mm-dd.log ): Failed to open stream: Permission denied... Fix: chmod -R 777 log","title":"FAQ"},{"location":"v5/installation/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"v5/installation/faq/#how-do-i-fix-common-permission-issues","text":"If running your project you encounter some permission issues, follow the below steps.","title":"How do I fix common permission issues?"},{"location":"v5/installation/getting-started/","text":"Clone the project Using your terminal, navigate inside the directory you want to download the project files into. Make sure that the directory is empty before proceeding to the download process. Once there, run the following command: git clone https://github.com/dotkernel/api.git .","title":"Getting Started"},{"location":"v5/installation/getting-started/#clone-the-project","text":"Using your terminal, navigate inside the directory you want to download the project files into. Make sure that the directory is empty before proceeding to the download process. Once there, run the following command: git clone https://github.com/dotkernel/api.git .","title":"Clone the project"},{"location":"v5/installation/test-the-installation/","text":"Test the installation Sending a GET request to the home page should output the following message: {\"message\": \"DotKernel API version 5\"} Old way of doing things, using PHP built-in server php -S 0.0.0.0:8080 -t public Running tests The project has 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit Running unit tests vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always Running functional tests vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Test the Installation"},{"location":"v5/installation/test-the-installation/#test-the-installation","text":"Sending a GET request to the home page should output the following message: {\"message\": \"DotKernel API version 5\"}","title":"Test the installation"},{"location":"v5/installation/test-the-installation/#old-way-of-doing-things-using-php-built-in-server","text":"php -S 0.0.0.0:8080 -t public","title":"Old way of doing things, using PHP built-in server"},{"location":"v5/installation/test-the-installation/#running-tests","text":"The project has 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit","title":"Running tests"},{"location":"v5/installation/test-the-installation/#running-unit-tests","text":"vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always","title":"Running unit tests"},{"location":"v5/installation/test-the-installation/#running-functional-tests","text":"vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Running functional tests"},{"location":"v5/introduction/file-structure/","text":"File structure Dotkernel API follows the PSR-4 standards. It is a good practice to standardize the file structure of projects. When using DotKernel API the following structure is installed by default: Main directories bin - executable files from CLI config - various configuration files data - should contain project-related data (AVOID storing sensitive data on VCS) documentation - should contain project-related documentation log - storage of log files generated by dot-error-log library public - publicly visible files. The webserver need to have this folder as www-document root folder. src - should contain the source code files test - should contain the test files Special purpose folders .github - containes workflow files .laminas-ci - contains laminas-ci workflow files src directory This directory contains all source code related to the Module. It should contain following directories, if they’re not empty: Handler - Action classes (similar to Controllers but can only perform one action) Entity - For database entities Service - Service classes Collection - Database entities collections Repository - Entity repository folder The above example is just some of the directories a project may include, but these should give you an idea of how the structure should look like. Other classes in the src directory may include InputFilter , EventListener , Helper , Command , Factory etc. The src directory should also contain 2 files: ConfigProvider.php - Provides configuration data RoutesDelegator.php - Module main routes entry file templates directory This directory contains the template files, used for example to help render e-mail templates. DotKernel API uses twig as Templating Engine. All template files have the extension .html.twig data directory This directory contains project-related data (such as cache, file uploads) We recommend using the following directory structure: data/cache - location where caches are stored data/oauth - encryption, private and public keys needed for authentication. data/doctrine - fixtures and migrations data/lock - lock files generated by dotkernel/dot-cli See more","title":"File Structure"},{"location":"v5/introduction/file-structure/#file-structure","text":"Dotkernel API follows the PSR-4 standards. It is a good practice to standardize the file structure of projects. When using DotKernel API the following structure is installed by default:","title":"File structure"},{"location":"v5/introduction/file-structure/#main-directories","text":"bin - executable files from CLI config - various configuration files data - should contain project-related data (AVOID storing sensitive data on VCS) documentation - should contain project-related documentation log - storage of log files generated by dot-error-log library public - publicly visible files. The webserver need to have this folder as www-document root folder. src - should contain the source code files test - should contain the test files","title":"Main directories"},{"location":"v5/introduction/file-structure/#special-purpose-folders","text":".github - containes workflow files .laminas-ci - contains laminas-ci workflow files","title":"Special purpose folders"},{"location":"v5/introduction/file-structure/#src-directory","text":"This directory contains all source code related to the Module. It should contain following directories, if they’re not empty: Handler - Action classes (similar to Controllers but can only perform one action) Entity - For database entities Service - Service classes Collection - Database entities collections Repository - Entity repository folder The above example is just some of the directories a project may include, but these should give you an idea of how the structure should look like. Other classes in the src directory may include InputFilter , EventListener , Helper , Command , Factory etc. The src directory should also contain 2 files: ConfigProvider.php - Provides configuration data RoutesDelegator.php - Module main routes entry file","title":"src directory"},{"location":"v5/introduction/file-structure/#templates-directory","text":"This directory contains the template files, used for example to help render e-mail templates. DotKernel API uses twig as Templating Engine. All template files have the extension .html.twig","title":"templates directory"},{"location":"v5/introduction/file-structure/#data-directory","text":"This directory contains project-related data (such as cache, file uploads) We recommend using the following directory structure: data/cache - location where caches are stored data/oauth - encryption, private and public keys needed for authentication. data/doctrine - fixtures and migrations data/lock - lock files generated by dotkernel/dot-cli See more","title":"data directory"},{"location":"v5/introduction/introduction/","text":"Introduction Based on Enrico Zimuel’s Zend Expressive API – Skeleton example, DotKernel API runs on Laminas and Mezzio components and implements standards like PSR-3, PSR-4, PSR-7, PSR-11 and PSR-15. Here is a list of the core components: Middleware Microframework (mezzio/mezzio) Error Handler (dotkernel/dot-errorhandler) Problem Details (mezzio/mezzio-problem-details) CORS (mezzio/mezzio-cors) Routing (mezzio/mezzio-fastroute) Authentication (mezzio/mezzio-authentication) Authorization (mezzio/mezzio-authorization) Config Aggregator (laminas/laminas-config-aggregator) Container (roave/psr-container-doctrine) Annotations (dotkernel/dot-annotated-services) Input Filter (laminas/laminas-inputfilter) Doctrine 2 ORM (doctrine/orm) Serializer/Deserializer (laminas/laminas-hydrator) Paginator (laminas/laminas-paginator) HAL (mezzio/mezzio-hal) CLI (dotkernel/dot-cli) TwigRenderer (mezzio/mezzio-twigrenderer) Fixtures (dotkernel/dot-data-fixtures) UUID (ramsey/uuid-doctrine) Doctrine 2 ORM For the persistence in a relational database management system we chose Doctrine ORM (object-relational mapper). The benefit of Doctrine for the programmer is the ability to focus on the object-oriented business logic and worry about persistence only as a secondary priority. Documentation Our documentation is Postman based. We use the following files in which we store information about every available endpoint ready to be tested: documentation/DotKernel_API.postman_collection.json documentation/DotKernel_API.postman_environment.json Hypertext Application Language For our API payloads (a value object for describing the API resource, its relational links and any embedded/child resources related to it) we chose mezzio-hal. CORS By using MezzioCorsMiddlewareCorsMiddleware , the CORS preflight will be recognized and the middleware will start to detect the proper CORS configuration. The Router is used to detect every allowed request method by executing a route match with all possible request methods. Therefore, for every preflight request, there is at least one Router request. OAuth 2.0 OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on your DotKernel API. We are using mezzio/mezzio-authentication-oauth2 which provides OAuth 2.0 authentication for Mezzio and PSR-7/PSR-15 applications by using league/oauth2-server package. Email It is not unlikely for an API to send emails depending on the use case. Here is another area where DotKernel API shines. Using DotMailServiceMailService provided by dotkernel/dot-mail you can easily send custom email templates. Configuration From authorization at request route level to API keys for your application, you can find every configuration variable in the config directory. Registering a new module can be done by including its ConfigProvider.php in config.php. Brand new middlewares should go into pipeline.php. Here you can edit the order in which they run and find more info about the currently included ones. You can further customize your api within the autoload directory where each configuration category has its own file. Routing Each module has a RoutesDelegator.php file for managing existing routes inside that specific module. It also allows a quick way of adding new routes by providing the route path, Middlewares that the route will use and the route name. You can allocate permissions per route name in order to restrict access for a user role to a specific route in config/autoload/authorization.global.php . Commands For registering new commands first make sure your command class extends SymfonyComponentConsoleCommandCommand . Then you can enable it by registering it in config/autoload/cli.global.php . File locker Here you will also find our brand-new file locker configuration, so you can easily turn it on or off (by default: 'enabled' =&gt; true ). Note: The File Locker System will create a command-{command-default-name}.lock file which will not let another instance of the same command to run until the previous one has finished. PSR Standards PSR-3 : Logger Interface – the application uses LoggerInterface for error logging PSR-4 : Autoloader – the application locates classes using an autoloader PSR-7 : HTTP message interfaces – the handlers return ResponseInterface PSR-11 : Container interface – the application is container-based PSR-15 : HTTP Server Request Handlers – the handlers implement RequestHandlerInterface Tests One of the best ways to ensure the quality of your product is to create and run functional and unit tests. You can find factory-made tests in the tests/AppTest/ folder, and you can also register your own. We have 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit Running unit tests vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always Running functional tests vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Introduction"},{"location":"v5/introduction/introduction/#introduction","text":"Based on Enrico Zimuel’s Zend Expressive API – Skeleton example, DotKernel API runs on Laminas and Mezzio components and implements standards like PSR-3, PSR-4, PSR-7, PSR-11 and PSR-15. Here is a list of the core components: Middleware Microframework (mezzio/mezzio) Error Handler (dotkernel/dot-errorhandler) Problem Details (mezzio/mezzio-problem-details) CORS (mezzio/mezzio-cors) Routing (mezzio/mezzio-fastroute) Authentication (mezzio/mezzio-authentication) Authorization (mezzio/mezzio-authorization) Config Aggregator (laminas/laminas-config-aggregator) Container (roave/psr-container-doctrine) Annotations (dotkernel/dot-annotated-services) Input Filter (laminas/laminas-inputfilter) Doctrine 2 ORM (doctrine/orm) Serializer/Deserializer (laminas/laminas-hydrator) Paginator (laminas/laminas-paginator) HAL (mezzio/mezzio-hal) CLI (dotkernel/dot-cli) TwigRenderer (mezzio/mezzio-twigrenderer) Fixtures (dotkernel/dot-data-fixtures) UUID (ramsey/uuid-doctrine)","title":"Introduction"},{"location":"v5/introduction/introduction/#doctrine-2-orm","text":"For the persistence in a relational database management system we chose Doctrine ORM (object-relational mapper). The benefit of Doctrine for the programmer is the ability to focus on the object-oriented business logic and worry about persistence only as a secondary priority.","title":"Doctrine 2 ORM"},{"location":"v5/introduction/introduction/#documentation","text":"Our documentation is Postman based. We use the following files in which we store information about every available endpoint ready to be tested: documentation/DotKernel_API.postman_collection.json documentation/DotKernel_API.postman_environment.json","title":"Documentation"},{"location":"v5/introduction/introduction/#hypertext-application-language","text":"For our API payloads (a value object for describing the API resource, its relational links and any embedded/child resources related to it) we chose mezzio-hal.","title":"Hypertext Application Language"},{"location":"v5/introduction/introduction/#cors","text":"By using MezzioCorsMiddlewareCorsMiddleware , the CORS preflight will be recognized and the middleware will start to detect the proper CORS configuration. The Router is used to detect every allowed request method by executing a route match with all possible request methods. Therefore, for every preflight request, there is at least one Router request.","title":"CORS"},{"location":"v5/introduction/introduction/#oauth-20","text":"OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on your DotKernel API. We are using mezzio/mezzio-authentication-oauth2 which provides OAuth 2.0 authentication for Mezzio and PSR-7/PSR-15 applications by using league/oauth2-server package.","title":"OAuth 2.0"},{"location":"v5/introduction/introduction/#email","text":"It is not unlikely for an API to send emails depending on the use case. Here is another area where DotKernel API shines. Using DotMailServiceMailService provided by dotkernel/dot-mail you can easily send custom email templates.","title":"Email"},{"location":"v5/introduction/introduction/#configuration","text":"From authorization at request route level to API keys for your application, you can find every configuration variable in the config directory. Registering a new module can be done by including its ConfigProvider.php in config.php. Brand new middlewares should go into pipeline.php. Here you can edit the order in which they run and find more info about the currently included ones. You can further customize your api within the autoload directory where each configuration category has its own file.","title":"Configuration"},{"location":"v5/introduction/introduction/#routing","text":"Each module has a RoutesDelegator.php file for managing existing routes inside that specific module. It also allows a quick way of adding new routes by providing the route path, Middlewares that the route will use and the route name. You can allocate permissions per route name in order to restrict access for a user role to a specific route in config/autoload/authorization.global.php .","title":"Routing"},{"location":"v5/introduction/introduction/#commands","text":"For registering new commands first make sure your command class extends SymfonyComponentConsoleCommandCommand . Then you can enable it by registering it in config/autoload/cli.global.php .","title":"Commands"},{"location":"v5/introduction/introduction/#file-locker","text":"Here you will also find our brand-new file locker configuration, so you can easily turn it on or off (by default: 'enabled' =&gt; true ). Note: The File Locker System will create a command-{command-default-name}.lock file which will not let another instance of the same command to run until the previous one has finished.","title":"File locker"},{"location":"v5/introduction/introduction/#psr-standards","text":"PSR-3 : Logger Interface – the application uses LoggerInterface for error logging PSR-4 : Autoloader – the application locates classes using an autoloader PSR-7 : HTTP message interfaces – the handlers return ResponseInterface PSR-11 : Container interface – the application is container-based PSR-15 : HTTP Server Request Handlers – the handlers implement RequestHandlerInterface","title":"PSR Standards"},{"location":"v5/introduction/introduction/#tests","text":"One of the best ways to ensure the quality of your product is to create and run functional and unit tests. You can find factory-made tests in the tests/AppTest/ folder, and you can also register your own. We have 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit","title":"Tests"},{"location":"v5/introduction/introduction/#running-unit-tests","text":"vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always","title":"Running unit tests"},{"location":"v5/introduction/introduction/#running-functional-tests","text":"vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Running functional tests"},{"location":"v5/introduction/packages/","text":"Packages dotkernel/dot-annotated-services - Dependency injection component using class attributes. dotkernel/dot-cache - Cache component extending symfony-cache dotkernel/dot-cli - Component for creating console applications based on laminas-cli dotkernel/dot-data-fixtures - Provides a CLI interface for listing &amp; executing doctrine data fixtures dotkernel/dot-errorhandler - Logging Error Handler for Middleware Applications dotkernel/dot-mail - Mail component based on laminas-mail dotkernel/dot-response-header - Middleware for setting custom response headers. laminas/laminas-component-installer - Composer plugin for injecting modules and configuration providers into application configuration laminas/laminas-config - Provides a nested object property based user interface for accessing this configuration data within application code laminas/laminas-config-aggregator - Lightweight library for collecting and merging configuration from different sources laminas/laminas-http - Provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests laminas/laminas-hydrator - Serialize objects to arrays, and vice versa laminas/laminas-inputfilter - Normalize and validate input sets from the web, APIs, the CLI, and more, including files laminas/laminas-paginator - Paginate collections of data from arbitrary sources laminas/laminas-stdlib - SPL extensions, array utilities, error handlers, and more laminas/laminas-text - Create FIGlets and text-based tables mezzio/mezzio - PSR-15 Middleware Microframework mezzio/mezzio-authentication-oauth2 - OAuth2 (server) authentication middleware for Mezzio and PSR-7 applications mezzio/mezzio-authorization-acl - laminas-permissions-acl adapter for mezzio-authorization mezzio/mezzio-authorization-rbac - mezzio authorization rbac adapter for laminas/laminas-permissions-rbac mezzio/mezzio-cors - CORS component for Mezzio and other PSR-15 middleware runners mezzio/mezzio-fastroute - FastRoute integration for Mezzio mezzio/mezzio-hal - Hypertext Application Language implementation for PHP and PSR-7 mezzio/mezzio-problem-details - Problem Details for PSR-7 HTTP APIs addressing the RFC 7807 standard mezzio/mezzio-twigrenderer - Twig integration for Mezzio ramsey/uuid-doctrine - Use ramsey/uuid as a Doctrine field type roave/psr-container-doctrine - Doctrine Factories for PSR-11 Containers symfony/filesystem - Provides basic utilities for the filesystem","title":"Packages"},{"location":"v5/introduction/packages/#packages","text":"dotkernel/dot-annotated-services - Dependency injection component using class attributes. dotkernel/dot-cache - Cache component extending symfony-cache dotkernel/dot-cli - Component for creating console applications based on laminas-cli dotkernel/dot-data-fixtures - Provides a CLI interface for listing &amp; executing doctrine data fixtures dotkernel/dot-errorhandler - Logging Error Handler for Middleware Applications dotkernel/dot-mail - Mail component based on laminas-mail dotkernel/dot-response-header - Middleware for setting custom response headers. laminas/laminas-component-installer - Composer plugin for injecting modules and configuration providers into application configuration laminas/laminas-config - Provides a nested object property based user interface for accessing this configuration data within application code laminas/laminas-config-aggregator - Lightweight library for collecting and merging configuration from different sources laminas/laminas-http - Provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests laminas/laminas-hydrator - Serialize objects to arrays, and vice versa laminas/laminas-inputfilter - Normalize and validate input sets from the web, APIs, the CLI, and more, including files laminas/laminas-paginator - Paginate collections of data from arbitrary sources laminas/laminas-stdlib - SPL extensions, array utilities, error handlers, and more laminas/laminas-text - Create FIGlets and text-based tables mezzio/mezzio - PSR-15 Middleware Microframework mezzio/mezzio-authentication-oauth2 - OAuth2 (server) authentication middleware for Mezzio and PSR-7 applications mezzio/mezzio-authorization-acl - laminas-permissions-acl adapter for mezzio-authorization mezzio/mezzio-authorization-rbac - mezzio authorization rbac adapter for laminas/laminas-permissions-rbac mezzio/mezzio-cors - CORS component for Mezzio and other PSR-15 middleware runners mezzio/mezzio-fastroute - FastRoute integration for Mezzio mezzio/mezzio-hal - Hypertext Application Language implementation for PHP and PSR-7 mezzio/mezzio-problem-details - Problem Details for PSR-7 HTTP APIs addressing the RFC 7807 standard mezzio/mezzio-twigrenderer - Twig integration for Mezzio ramsey/uuid-doctrine - Use ramsey/uuid as a Doctrine field type roave/psr-container-doctrine - Doctrine Factories for PSR-11 Containers symfony/filesystem - Provides basic utilities for the filesystem","title":"Packages"},{"location":"v5/introduction/server-requirements/","text":"Server Requirements For production, we highly recommend a *nix based system. Webserver Apache &gt;= 2.2 or Nginx mod_rewrite .htaccess support (AllowOverride All) PHP &gt;= 8.2 Both mod_php and FCGI (FPM) are supported. Required Settings and Modules &amp; Extensions memory_limit &gt;= 128M upload_max_filesize and post_max_size &gt;= 100M (depending on your data) mbstring CLI SAPI (for Cron Jobs) Composer (added to $PATH) RDBMS MySQL / MariaDB &gt;= 5.5.3 Recommended extensions opcache pdo_mysql or mysqli (if using MySQL or MariaDB as RDBMS) dom - if working with markup files structure (html, xml, etc) simplexml - working with xml files gd, exif - if working with images zlib, zip, bz2 - if compessing files curl (required if APIs are used)","title":"Server Requirements"},{"location":"v5/introduction/server-requirements/#server-requirements","text":"For production, we highly recommend a *nix based system.","title":"Server Requirements"},{"location":"v5/introduction/server-requirements/#webserver","text":"Apache &gt;= 2.2 or Nginx mod_rewrite .htaccess support (AllowOverride All)","title":"Webserver"},{"location":"v5/introduction/server-requirements/#php-82","text":"Both mod_php and FCGI (FPM) are supported.","title":"PHP &gt;= 8.2"},{"location":"v5/introduction/server-requirements/#required-settings-and-modules-extensions","text":"memory_limit &gt;= 128M upload_max_filesize and post_max_size &gt;= 100M (depending on your data) mbstring CLI SAPI (for Cron Jobs) Composer (added to $PATH)","title":"Required Settings and Modules &amp; Extensions"},{"location":"v5/introduction/server-requirements/#rdbms","text":"MySQL / MariaDB &gt;= 5.5.3","title":"RDBMS"},{"location":"v5/introduction/server-requirements/#recommended-extensions","text":"opcache pdo_mysql or mysqli (if using MySQL or MariaDB as RDBMS) dom - if working with markup files structure (html, xml, etc) simplexml - working with xml files gd, exif - if working with images zlib, zip, bz2 - if compessing files curl (required if APIs are used)","title":"Recommended extensions"},{"location":"v5/transition-from-api-tools/api-tools-vs-dotkernel-api/","text":"Laminas API Tools compared to DotKernel API API Tools (formerly Apigility) DotKernel API URL api-tools Dotkernel API First Release 2012 2018 PHP Version &lt;= 8.2 &gt;= 8.1 Architecture MVC, Event Driven Middleware OSS Lifecycle Archived Style REST, RPC REST Versioning Yes Deprecations * Documentation Swagger (Automated) Postman (Manual) * Content-Negotiation Custom Custom License BSD-3 MIT Default DB Layer laminas-db doctrine-orm Authorization ACL RBAC-guard Authentication HTTP Basic/Digest OAuth2.0 OAuth2.0 CI/CD Yes Yes Unit Tests Yes Yes Endpoint Generator Yes Under development PSR PSR-7 PSR-7, PSR-15 Note Versioning is replaced by Deprecations, using evolution strategy Version 5 ( Roadmap ) will implement OpenAPi 3.0","title":"Laminas API Tools vs DotKernel API"},{"location":"v5/transition-from-api-tools/api-tools-vs-dotkernel-api/#laminas-api-tools-compared-to-dotkernel-api","text":"API Tools (formerly Apigility) DotKernel API URL api-tools Dotkernel API First Release 2012 2018 PHP Version &lt;= 8.2 &gt;= 8.1 Architecture MVC, Event Driven Middleware OSS Lifecycle Archived Style REST, RPC REST Versioning Yes Deprecations * Documentation Swagger (Automated) Postman (Manual) * Content-Negotiation Custom Custom License BSD-3 MIT Default DB Layer laminas-db doctrine-orm Authorization ACL RBAC-guard Authentication HTTP Basic/Digest OAuth2.0 OAuth2.0 CI/CD Yes Yes Unit Tests Yes Yes Endpoint Generator Yes Under development PSR PSR-7 PSR-7, PSR-15","title":"Laminas API Tools compared to DotKernel API"},{"location":"v5/transition-from-api-tools/api-tools-vs-dotkernel-api/#note","text":"Versioning is replaced by Deprecations, using evolution strategy Version 5 ( Roadmap ) will implement OpenAPi 3.0","title":"Note"},{"location":"v5/transition-from-api-tools/discovery-phase/","text":"Discovery phase for a current system built using API Tools [WIP] In order to transition a system built using api-tools to Dotkernel API , we need to analyze the core components of it. Database there is a database in the current API ? which is the connection to database which library is used for database interaction ( laminas-db, doctrine 2, eloquent, or else ) Note Dotkernel API is tested only with MariaDB version 10.6 and 10.11 LTS Authentication and Authorization how authentication is done ? (basic, digest, oauth2, etc.) how authorization is done ? (acl, rbac) Modules analyze configuration files of the modules (what needs to be configured in order to use a module) analyze routes (which are the routes, protection rules, which one need auth, etc.) analyze response format (content negotiation and validation, which ones are json, hal, views, etc.) analyze input field validations Custom functionalities Analyze the custom code (code that cannot be generated through Admin UI and require manual implementation) For instance: caching events services extra installed packages and libraries jobs and queues third-parties tests","title":"Discovery Phase"},{"location":"v5/transition-from-api-tools/discovery-phase/#discovery-phase-for-a-current-system-built-using-api-tools-wip","text":"In order to transition a system built using api-tools to Dotkernel API , we need to analyze the core components of it.","title":"Discovery phase for a current system built using API Tools [WIP]"},{"location":"v5/transition-from-api-tools/discovery-phase/#database","text":"there is a database in the current API ? which is the connection to database which library is used for database interaction ( laminas-db, doctrine 2, eloquent, or else )","title":"Database"},{"location":"v5/transition-from-api-tools/discovery-phase/#authentication-and-authorization","text":"how authentication is done ? (basic, digest, oauth2, etc.) how authorization is done ? (acl, rbac)","title":"Authentication and Authorization"},{"location":"v5/transition-from-api-tools/discovery-phase/#modules","text":"analyze configuration files of the modules (what needs to be configured in order to use a module) analyze routes (which are the routes, protection rules, which one need auth, etc.) analyze response format (content negotiation and validation, which ones are json, hal, views, etc.) analyze input field validations","title":"Modules"},{"location":"v5/transition-from-api-tools/discovery-phase/#custom-functionalities","text":"Analyze the custom code (code that cannot be generated through Admin UI and require manual implementation) For instance: caching events services extra installed packages and libraries jobs and queues third-parties tests","title":"Custom functionalities"},{"location":"v5/transition-from-api-tools/transition-approach/","text":"Transition approach [WIP] Dotkernel API is not a one-to-one replacement of api-tools ( former Apigility), but is only a potential solution to migrate to. Functionalities, components and architecture are different. See the Comparison between Dotkernel APi and api-tools Business cases There are at least 2 approaches for this transition: Clone 1:1 and recreate all endpoints and entities Build a new version of the current API using Dotkernel API and keep it running as separate platforms until the sunset of the current version of api-tools","title":"Transition Approach"},{"location":"v5/transition-from-api-tools/transition-approach/#transition-approach-wip","text":"Dotkernel API is not a one-to-one replacement of api-tools ( former Apigility), but is only a potential solution to migrate to. Functionalities, components and architecture are different. See the Comparison between Dotkernel APi and api-tools","title":"Transition approach [WIP]"},{"location":"v5/transition-from-api-tools/transition-approach/#business-cases","text":"There are at least 2 approaches for this transition:","title":"Business cases"},{"location":"v5/tutorials/create-book-module/","text":"Implementing a book module in DotKernel API File structure The below file structure is just an example, you can have multiple components such as event listeners, wrappers, etc. . └── src/ └── Book/ └── src/ ├── Collection/ │ └── BookCollection.php ├── Entity/ │ └── Book.php ├── Handler/ │ └── BookHandler.php ├── InputFilter/ │ ├── Input/ │ │ ├── AuthorInput.php │ │ ├── NameInput.php │ │ └── ReleaseDateInput.php │ └── BookInputFilter.php ├── Repository/ │ └── BookRepository.php ├── Service/ │ ├── BookService.php │ └── BookServiceInterface.php ├── ConfigProvider.php └── RoutesDelegator.php src/Book/src/Collection/BookCollection.php - a collection refers to a container for a group of related objects, typically used to manage sets of related entities fetched from a database src/Book/src/Entity/Book.php - an entity refers to a PHP class that represents a persistent object or data structure src/Book/src/Handler/BookHandler.php - handlers are middleware that can handle requests based on an action src/Book/src/Repository/BookRepository.php - a repository is a class responsible for querying and retrieving entities from the database src/Book/src/Service/BookService.php - is a class or component responsible for performing a specific task or providing functionality to other parts of the application src/Book/src/ConfigProvider.php - is a class that provides configuration for various aspects of the framework or application src/Book/src/RoutesDelegator.php - a routes delegator is a delegator factory responsible for configuring routing middleware based on routing configuration provided by the application src/Book/src/InputFilter/BookInputFilter.php - input filters and validators src/Book/src/InputFilter/Input/* - input filters and validator configurations File creation and contents src/Book/src/Collection/BookCollection.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Collection; use Api\\App\\Collection\\ResourceCollection; class BookCollection extends ResourceCollection { } src/Book/src/Entity/Book.php To keep things simple in this tutorial our book will have 3 properties: name , author and release date . &lt;?php declare(strict_types=1); namespace Api\\Book\\Entity; use Api\\App\\Entity\\AbstractEntity; use Api\\Book\\Repository\\BookRepository; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(\"book\")] class Book extends AbstractEntity { #[ORM\\Column(name: \"name\", type: \"string\", length: 100)] protected string $name; #[ORM\\Column(name: \"author\", type: \"string\", length: 100)] protected string $author; #[ORM\\Column(name: \"releaseDate\", type: \"datetime_immutable\")] protected DateTimeImmutable $releaseDate; public function __construct(string $name, string $author, DateTimeImmutable $releaseDate) { parent::__construct(); $this-&gt;setName($name); $this-&gt;setAuthor($author); $this-&gt;setReleaseDate($releaseDate); } public function getName(): string { return $this-&gt;name; } public function setName(string $name): self { $this-&gt;name = $name; return $this; } public function getAuthor(): string { return $this-&gt;author; } public function setAuthor(string $author): self { $this-&gt;author = $author; return $this; } public function getReleaseDate(): DateTimeImmutable { return $this-&gt;releaseDate; } public function setReleaseDate(DateTimeImmutable $releaseDate): self { $this-&gt;releaseDate = $releaseDate; return $this; } public function getArrayCopy(): array { return [ 'uuid' =&gt; $this-&gt;getUuid()-&gt;toString(), 'name' =&gt; $this-&gt;getName(), 'author' =&gt; $this-&gt;getAuthor(), 'releaseDate' =&gt; $this-&gt;getReleaseDate(), ]; } } src/Book/src/Repository/BookRepository.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Repository; use Api\\App\\Helper\\PaginationHelper; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Doctrine\\ORM\\EntityRepository; use Dot\\DependencyInjection\\Attribute\\Entity; /** * @extends EntityRepository&lt;object&gt; */ #[Entity(name: Book::class)] class BookRepository extends EntityRepository { public function saveBook(Book $book): Book { $this-&gt;getEntityManager()-&gt;persist($book); $this-&gt;getEntityManager()-&gt;flush(); return $book; } public function getBooks(array $filters = []): BookCollection { $page = PaginationHelper::getOffsetAndLimit($filters); $qb = $this -&gt;getEntityManager() -&gt;createQueryBuilder() -&gt;select('book') -&gt;from(Book::class, 'book') -&gt;orderBy($filters['order'] ?? 'book.created', $filters['dir'] ?? 'desc') -&gt;setFirstResult($page['offset']) -&gt;setMaxResults($page['limit']); $qb-&gt;getQuery()-&gt;useQueryCache(true); return new BookCollection($qb, false); } } src/Book/src/Service/BookService.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; use Api\\Book\\Entity\\Book; use Api\\Book\\Repository\\BookRepository; use Dot\\DependencyInjection\\Attribute\\Inject; use DateTimeImmutable; class BookService implements BookServiceInterface { #[Inject(BookRepository::class)] public function __construct(protected BookRepository $bookRepository) { } public function createBook(array $data): Book { $book = new Book( $data['name'], $data['author'], new DateTimeImmutable($data['releaseDate']) ); return $this-&gt;bookRepository-&gt;saveBook($book); } public function getBooks(array $filters = []) { return $this-&gt;bookRepository-&gt;getBooks($filters); } } src/Book/src/Service/BookServiceInterface.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; interface BookServiceInterface { } src/Book/src/ConfigProvider.php &lt;?php declare(strict_types=1); namespace Api\\Book; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Api\\Book\\Handler\\BookHandler; use Api\\Book\\Repository\\BookRepository; use Api\\Book\\Service\\BookService; use Api\\Book\\Service\\BookServiceInterface; use Dot\\DependencyInjection\\Factory\\AttributedRepositoryFactory; use Dot\\DependencyInjection\\Factory\\AttributedServiceFactory; use Mezzio\\Hal\\Metadata\\MetadataMap; use Api\\App\\ConfigProvider as AppConfigProvider; class ConfigProvider { public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), MetadataMap::class =&gt; $this-&gt;getHalConfig(), ]; } public function getDependencies(): array { return [ 'factories' =&gt; [ BookHandler::class =&gt; AttributedServiceFactory::class, BookService::class =&gt; AttributedServiceFactory::class, BookRepository::class =&gt; AttributedRepositoryFactory::class, ], 'aliases' =&gt; [ BookServiceInterface::class =&gt; BookService::class, ], ]; } public function getHalConfig(): array { return [ AppConfigProvider::getCollection(BookCollection::class, 'books.list', 'books'), AppConfigProvider::getResource(Book::class, 'book.create'), ]; } } src/Book/src/RoutesDelegator.php &lt;?php namespace Api\\Book; use Api\\Book\\Handler\\BookHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { /** @var Application $app */ $app = $callback(); $app-&gt;get( '/books', BookHandler::class, 'books.list' ); $app-&gt;post( '/book', BookHandler::class, 'book.create' ); return $app; } } src/Book/src/InputFilter/BookInputFilter.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter; use Api\\Book\\InputFilter\\Input\\AuthorInput; use Api\\Book\\InputFilter\\Input\\NameInput; use Api\\Book\\InputFilter\\Input\\ReleaseDateInput; use Laminas\\InputFilter\\InputFilter; class BookInputFilter extends InputFilter { public function __construct() { $this-&gt;add(new NameInput('name')); $this-&gt;add(new AuthorInput('author')); $this-&gt;add(new ReleaseDateInput('releaseDate')); } } src/Book/src/InputFilter/Input/AuthorInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class AuthorInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'author'), ], true); } } src/Book/src/InputFilter/Input/NameInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class NameInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'name'), ], true); } } src/Book/src/InputFilter/Input/ReleaseDateInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\Date; use Laminas\\Validator\\NotEmpty; class ReleaseDateInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(Date::class, [ 'message' =&gt; sprintf(Message::INVALID_VALUE, 'releaseDate'), ], true); } } src/Book/src/Handler/BookHandler.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Handler; use Api\\App\\Handler\\ResponseTrait; use Api\\Book\\InputFilter\\BookInputFilter; use Api\\Book\\Service\\BookServiceInterface; use Mezzio\\Hal\\HalResponseFactory; use Mezzio\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Dot\\DependencyInjection\\Attribute\\Inject; class BookHandler implements RequestHandlerInterface { use HandlerTrait; #[Inject( HalResponseFactory::class, ResourceGenerator::class, BookServiceInterface::class )] public function __construct( protected HalResponseFactory $responseFactory, protected ResourceGenerator $resourceGenerator, protected BookServiceInterface $bookService ) { } public function get(ServerRequestInterface $request): ResponseInterface { $books = $this-&gt;bookService-&gt;getBooks($request-&gt;getQueryParams()); return $this-&gt;createResponse($request, $books); } public function post(ServerRequestInterface $request): ResponseInterface { $inputFilter = (new BookInputFilter())-&gt;setData($request-&gt;getParsedBody()); if (! $inputFilter-&gt;isValid()) { return $this-&gt;errorResponse($inputFilter-&gt;getMessages()); } $book = $this-&gt;bookService-&gt;createBook($inputFilter-&gt;getValues()); return $this-&gt;createResponse($request, $book); } } Configuring and registering the new module Once you set up all the files as in the example above, you will need to do a few additional configurations: register the namespace by adding this line \"Api\\\\Book\\\\\": \"src/Book/src/\", in composer.json under the autoload.psr-4 key register the module by adding Api\\Book\\ConfigProvider::class, under Api\\User\\ConfigProvider::class, register the module's routes by adding \\Api\\Book\\RoutesDelegator::class, under \\Api\\User\\RoutesDelegator::class, in src/App/src/ConfigProvider.php update Composer autoloader by running the command: composer dump-autoload It should look like this: public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, \\Api\\Admin\\RoutesDelegator::class, \\Api\\User\\RoutesDelegator::class, \\Api\\Book\\RoutesDelegator::class, ], ], 'factories' =&gt; [ ... ] ... In src/config/autoload/doctrine.global.php add this under the doctrine.driver key: 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], Api\\\\Book\\Entity' =&gt; 'BookEntities', add this under the doctrine.driver.drivers key Example: &lt;?php ... return [ 'doctrine' =&gt; [ ... 'driver' =&gt; [ 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, 'drivers' =&gt; [ 'Api\\\\App\\Entity' =&gt; 'AppEntities', 'Api\\\\Admin\\\\Entity' =&gt; 'AdminEntities', 'Api\\\\User\\\\Entity' =&gt; 'UserEntities', 'Api\\\\Book\\Entity' =&gt; 'BookEntities', ], ], 'AdminEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Admin/src/Entity', ], 'UserEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/User/src/Entity', ], 'AppEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/App/src/Entity', ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], ], ... Next we need to configure access to the newly created endpoints, add books.list and book.create to the authorization rbac array, under the UserRole::ROLE_GUEST key. Make sure you read and understand the rbac documentation. Migrations We created the Book entity, but we didn't create the associated table for it. Doctrine can handle the table creation, run the following command: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' This will check for differences between your entities and database structure and create migration files if necessary, in data/doctrine/migrations . To execute the migrations run: vendor/bin/doctrine-migrations migrate Checking endpoints If we did everything as planned we can call the http://0.0.0.0:8080/book endpoint and create a new book: curl -X POST http://0.0.0.0:8080/book -H \"Content-Type: application/json\" -d '{\"name\": \"test\", \"author\": \"author name\", \"releaseDate\": \"2023-03-03\"}' To list the books use: curl http://0.0.0.0:8080/books","title":"Creating a book module"},{"location":"v5/tutorials/create-book-module/#implementing-a-book-module-in-dotkernel-api","text":"","title":"Implementing a book module in DotKernel API"},{"location":"v5/tutorials/create-book-module/#file-structure","text":"The below file structure is just an example, you can have multiple components such as event listeners, wrappers, etc. . └── src/ └── Book/ └── src/ ├── Collection/ │ └── BookCollection.php ├── Entity/ │ └── Book.php ├── Handler/ │ └── BookHandler.php ├── InputFilter/ │ ├── Input/ │ │ ├── AuthorInput.php │ │ ├── NameInput.php │ │ └── ReleaseDateInput.php │ └── BookInputFilter.php ├── Repository/ │ └── BookRepository.php ├── Service/ │ ├── BookService.php │ └── BookServiceInterface.php ├── ConfigProvider.php └── RoutesDelegator.php src/Book/src/Collection/BookCollection.php - a collection refers to a container for a group of related objects, typically used to manage sets of related entities fetched from a database src/Book/src/Entity/Book.php - an entity refers to a PHP class that represents a persistent object or data structure src/Book/src/Handler/BookHandler.php - handlers are middleware that can handle requests based on an action src/Book/src/Repository/BookRepository.php - a repository is a class responsible for querying and retrieving entities from the database src/Book/src/Service/BookService.php - is a class or component responsible for performing a specific task or providing functionality to other parts of the application src/Book/src/ConfigProvider.php - is a class that provides configuration for various aspects of the framework or application src/Book/src/RoutesDelegator.php - a routes delegator is a delegator factory responsible for configuring routing middleware based on routing configuration provided by the application src/Book/src/InputFilter/BookInputFilter.php - input filters and validators src/Book/src/InputFilter/Input/* - input filters and validator configurations","title":"File structure"},{"location":"v5/tutorials/create-book-module/#file-creation-and-contents","text":"src/Book/src/Collection/BookCollection.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Collection; use Api\\App\\Collection\\ResourceCollection; class BookCollection extends ResourceCollection { } src/Book/src/Entity/Book.php To keep things simple in this tutorial our book will have 3 properties: name , author and release date . &lt;?php declare(strict_types=1); namespace Api\\Book\\Entity; use Api\\App\\Entity\\AbstractEntity; use Api\\Book\\Repository\\BookRepository; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(\"book\")] class Book extends AbstractEntity { #[ORM\\Column(name: \"name\", type: \"string\", length: 100)] protected string $name; #[ORM\\Column(name: \"author\", type: \"string\", length: 100)] protected string $author; #[ORM\\Column(name: \"releaseDate\", type: \"datetime_immutable\")] protected DateTimeImmutable $releaseDate; public function __construct(string $name, string $author, DateTimeImmutable $releaseDate) { parent::__construct(); $this-&gt;setName($name); $this-&gt;setAuthor($author); $this-&gt;setReleaseDate($releaseDate); } public function getName(): string { return $this-&gt;name; } public function setName(string $name): self { $this-&gt;name = $name; return $this; } public function getAuthor(): string { return $this-&gt;author; } public function setAuthor(string $author): self { $this-&gt;author = $author; return $this; } public function getReleaseDate(): DateTimeImmutable { return $this-&gt;releaseDate; } public function setReleaseDate(DateTimeImmutable $releaseDate): self { $this-&gt;releaseDate = $releaseDate; return $this; } public function getArrayCopy(): array { return [ 'uuid' =&gt; $this-&gt;getUuid()-&gt;toString(), 'name' =&gt; $this-&gt;getName(), 'author' =&gt; $this-&gt;getAuthor(), 'releaseDate' =&gt; $this-&gt;getReleaseDate(), ]; } } src/Book/src/Repository/BookRepository.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Repository; use Api\\App\\Helper\\PaginationHelper; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Doctrine\\ORM\\EntityRepository; use Dot\\DependencyInjection\\Attribute\\Entity; /** * @extends EntityRepository&lt;object&gt; */ #[Entity(name: Book::class)] class BookRepository extends EntityRepository { public function saveBook(Book $book): Book { $this-&gt;getEntityManager()-&gt;persist($book); $this-&gt;getEntityManager()-&gt;flush(); return $book; } public function getBooks(array $filters = []): BookCollection { $page = PaginationHelper::getOffsetAndLimit($filters); $qb = $this -&gt;getEntityManager() -&gt;createQueryBuilder() -&gt;select('book') -&gt;from(Book::class, 'book') -&gt;orderBy($filters['order'] ?? 'book.created', $filters['dir'] ?? 'desc') -&gt;setFirstResult($page['offset']) -&gt;setMaxResults($page['limit']); $qb-&gt;getQuery()-&gt;useQueryCache(true); return new BookCollection($qb, false); } } src/Book/src/Service/BookService.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; use Api\\Book\\Entity\\Book; use Api\\Book\\Repository\\BookRepository; use Dot\\DependencyInjection\\Attribute\\Inject; use DateTimeImmutable; class BookService implements BookServiceInterface { #[Inject(BookRepository::class)] public function __construct(protected BookRepository $bookRepository) { } public function createBook(array $data): Book { $book = new Book( $data['name'], $data['author'], new DateTimeImmutable($data['releaseDate']) ); return $this-&gt;bookRepository-&gt;saveBook($book); } public function getBooks(array $filters = []) { return $this-&gt;bookRepository-&gt;getBooks($filters); } } src/Book/src/Service/BookServiceInterface.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; interface BookServiceInterface { } src/Book/src/ConfigProvider.php &lt;?php declare(strict_types=1); namespace Api\\Book; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Api\\Book\\Handler\\BookHandler; use Api\\Book\\Repository\\BookRepository; use Api\\Book\\Service\\BookService; use Api\\Book\\Service\\BookServiceInterface; use Dot\\DependencyInjection\\Factory\\AttributedRepositoryFactory; use Dot\\DependencyInjection\\Factory\\AttributedServiceFactory; use Mezzio\\Hal\\Metadata\\MetadataMap; use Api\\App\\ConfigProvider as AppConfigProvider; class ConfigProvider { public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), MetadataMap::class =&gt; $this-&gt;getHalConfig(), ]; } public function getDependencies(): array { return [ 'factories' =&gt; [ BookHandler::class =&gt; AttributedServiceFactory::class, BookService::class =&gt; AttributedServiceFactory::class, BookRepository::class =&gt; AttributedRepositoryFactory::class, ], 'aliases' =&gt; [ BookServiceInterface::class =&gt; BookService::class, ], ]; } public function getHalConfig(): array { return [ AppConfigProvider::getCollection(BookCollection::class, 'books.list', 'books'), AppConfigProvider::getResource(Book::class, 'book.create'), ]; } } src/Book/src/RoutesDelegator.php &lt;?php namespace Api\\Book; use Api\\Book\\Handler\\BookHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { /** @var Application $app */ $app = $callback(); $app-&gt;get( '/books', BookHandler::class, 'books.list' ); $app-&gt;post( '/book', BookHandler::class, 'book.create' ); return $app; } } src/Book/src/InputFilter/BookInputFilter.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter; use Api\\Book\\InputFilter\\Input\\AuthorInput; use Api\\Book\\InputFilter\\Input\\NameInput; use Api\\Book\\InputFilter\\Input\\ReleaseDateInput; use Laminas\\InputFilter\\InputFilter; class BookInputFilter extends InputFilter { public function __construct() { $this-&gt;add(new NameInput('name')); $this-&gt;add(new AuthorInput('author')); $this-&gt;add(new ReleaseDateInput('releaseDate')); } } src/Book/src/InputFilter/Input/AuthorInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class AuthorInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'author'), ], true); } } src/Book/src/InputFilter/Input/NameInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class NameInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'name'), ], true); } } src/Book/src/InputFilter/Input/ReleaseDateInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\Date; use Laminas\\Validator\\NotEmpty; class ReleaseDateInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(Date::class, [ 'message' =&gt; sprintf(Message::INVALID_VALUE, 'releaseDate'), ], true); } } src/Book/src/Handler/BookHandler.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Handler; use Api\\App\\Handler\\ResponseTrait; use Api\\Book\\InputFilter\\BookInputFilter; use Api\\Book\\Service\\BookServiceInterface; use Mezzio\\Hal\\HalResponseFactory; use Mezzio\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Dot\\DependencyInjection\\Attribute\\Inject; class BookHandler implements RequestHandlerInterface { use HandlerTrait; #[Inject( HalResponseFactory::class, ResourceGenerator::class, BookServiceInterface::class )] public function __construct( protected HalResponseFactory $responseFactory, protected ResourceGenerator $resourceGenerator, protected BookServiceInterface $bookService ) { } public function get(ServerRequestInterface $request): ResponseInterface { $books = $this-&gt;bookService-&gt;getBooks($request-&gt;getQueryParams()); return $this-&gt;createResponse($request, $books); } public function post(ServerRequestInterface $request): ResponseInterface { $inputFilter = (new BookInputFilter())-&gt;setData($request-&gt;getParsedBody()); if (! $inputFilter-&gt;isValid()) { return $this-&gt;errorResponse($inputFilter-&gt;getMessages()); } $book = $this-&gt;bookService-&gt;createBook($inputFilter-&gt;getValues()); return $this-&gt;createResponse($request, $book); } }","title":"File creation and contents"},{"location":"v5/tutorials/create-book-module/#configuring-and-registering-the-new-module","text":"Once you set up all the files as in the example above, you will need to do a few additional configurations: register the namespace by adding this line \"Api\\\\Book\\\\\": \"src/Book/src/\", in composer.json under the autoload.psr-4 key register the module by adding Api\\Book\\ConfigProvider::class, under Api\\User\\ConfigProvider::class, register the module's routes by adding \\Api\\Book\\RoutesDelegator::class, under \\Api\\User\\RoutesDelegator::class, in src/App/src/ConfigProvider.php update Composer autoloader by running the command: composer dump-autoload It should look like this: public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, \\Api\\Admin\\RoutesDelegator::class, \\Api\\User\\RoutesDelegator::class, \\Api\\Book\\RoutesDelegator::class, ], ], 'factories' =&gt; [ ... ] ... In src/config/autoload/doctrine.global.php add this under the doctrine.driver key: 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], Api\\\\Book\\Entity' =&gt; 'BookEntities', add this under the doctrine.driver.drivers key Example: &lt;?php ... return [ 'doctrine' =&gt; [ ... 'driver' =&gt; [ 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, 'drivers' =&gt; [ 'Api\\\\App\\Entity' =&gt; 'AppEntities', 'Api\\\\Admin\\\\Entity' =&gt; 'AdminEntities', 'Api\\\\User\\\\Entity' =&gt; 'UserEntities', 'Api\\\\Book\\Entity' =&gt; 'BookEntities', ], ], 'AdminEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Admin/src/Entity', ], 'UserEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/User/src/Entity', ], 'AppEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/App/src/Entity', ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], ], ... Next we need to configure access to the newly created endpoints, add books.list and book.create to the authorization rbac array, under the UserRole::ROLE_GUEST key. Make sure you read and understand the rbac documentation.","title":"Configuring and registering the new module"},{"location":"v5/tutorials/create-book-module/#migrations","text":"We created the Book entity, but we didn't create the associated table for it. Doctrine can handle the table creation, run the following command: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' This will check for differences between your entities and database structure and create migration files if necessary, in data/doctrine/migrations . To execute the migrations run: vendor/bin/doctrine-migrations migrate","title":"Migrations"},{"location":"v5/tutorials/create-book-module/#checking-endpoints","text":"If we did everything as planned we can call the http://0.0.0.0:8080/book endpoint and create a new book: curl -X POST http://0.0.0.0:8080/book -H \"Content-Type: application/json\" -d '{\"name\": \"test\", \"author\": \"author name\", \"releaseDate\": \"2023-03-03\"}' To list the books use: curl http://0.0.0.0:8080/books","title":"Checking endpoints"},{"location":"v5/tutorials/token-authentication/","text":"Token authentication What is token authentication? Token authentication means making a request to an API endpoint while also sending a special header that contains an access token. The access token was previously generated by (usually) the same API as the one you are sending requests to and it consists of an alphanumeric string. How does it work? In order to protect specific resources, clients need to be authenticated with user/admin roles. These roles are identified from the access token sent via the Authorization header. When DotKernel API receives a request, it tries to read the access token. If it does not find an access token, client has guest role: if the requested endpoint needs no authentication, the requested resource is returned else, a 403 Forbidden response is returned Else, client's account is identified and client has admin / user role (the one assigned in their account) if the requested endpoint is accessible to the client, the requested resource is returned else, a 403 Forbidden response is returned DotKernel API provides out-of-the-box both an admin and a user account. The admin account with role set to both superuser and admin with the following credentials: identity : admin password : dotkernel The user account with role set to both user and guest with the following credentials: identify : test@dotkernel.com password : dotkernel Flow client sends API request with credentials API returns a JSON object containing a new access and refresh token client sends API request using Authentication header containing the previously generated access token API returns requested resource Note The first two steps need to executed only once. Access token should be stored and reused for all upcoming requests. Refresh token should be stored and used to refresh expired access token. For a better overview of the flow, see the below image: Generate admin access token Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" } Note Replace &lt;identity&gt; with your admin account's identity and &lt;password&gt; with your admin account's password . Both fields come from table admin . Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"admin\", \"password\": \"dotkernel\" }' Generate user access token Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" } Note Replace &lt;identity&gt; with your user account's identity and &lt;password&gt; with your user account's password . Both fields come from table user . Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"test@dotkernel.com\", \"password\": \"dotkernel\" }' Response on success You should see a 200 OK response with the following JSON body: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.e...wuE39ON1mS5mnTKfA_dSpSWxOmNQdny_AKIbc1qZjMfS24qSUV8HIoOw\", \"refresh_token\": \"def502005a035c8dfe5456d27e85069813a4f8...0b844e843cd62865662a0e723165752dfd7012491502d3d819c2a61d\" } Field description: token_type : token type to be set when sending the Authorization header (example: Authorization: Bearer eyJ0e... ) expires_in : access token lifetime (modify in: config/autoload/local.php &gt; authentication . access_token_expire ) access_token : generated access token (store it for later use) refresh_token : generated refresh token (store it for regenerating expired access token) Response on failure You should see a 400 Bad Request response with the following JSON body: { \"error\": \"Invalid credentials.\", \"error_description\": \"Invalid credentials.\", \"message\": \"Invalid credentials.\" } Refresh admin access token Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" } Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/refresh-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"refresh_token\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }' Note Make sure you replace &lt;refresh-token&gt; with the refresh token generated with the access token. Refresh user access token Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" } Test using curl Execute the below command: curl --location 'https://api.dotkernel.net/security/refresh-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }' Note Make sure you replace &lt;refresh-token&gt; with the refresh token generated with the access token. Response on success You should see a 200 OK response with the following JSON body: { \"token_type\": \"Bearer\", \"expires_in\": 86400, \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.e...wuE39ON1mS5mnTKfA_dSpSWxOmNQdny_AKIbc1qZjMfS24qSUV8HIoOw\", \"refresh_token\": \"def502005a035c8dfe5456d27e85069813a4f8...0b844e843cd62865662a0e723165752dfd7012491502d3d819c2a61d\" } Field description: token_type : token type to be set when sending the Authorization header (example: Authorization: Bearer eyJ0e... ) expires_in : access token lifetime (change here: config/autoload/local.php authentication -&gt; access_token_expire ) access_token : generated access token (store it for later use) refresh_token : generated refresh token (store it for regenerating expired access token) Response on failure You should see a 401 Unauthorized response with the following JSON body: { \"error\": \"invalid_request\", \"error_description\": \"The refresh token is invalid.\", \"hint\": \"Cannot decrypt the refresh token\", \"message\": \"The refresh token is invalid.\" } Test admin authentication flow Step 1: Fail to fetch protected API content Try to view your admin account by executing: curl --location 'https://api.dotkernel.net/admin/my-account' You should get a 403 Forbidden JSON response. Step 2: Generate access token Generate admin access token by executing: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"admin\", \"password\": \"dotkernel\" }' You should get a 200 OK JSON response. Store the value of access_token for later use. Step 3: Successfully fetch protected API content Try again viewing your admin account by executing: curl --location 'https://api.dotkernel.net/admin/my-account' \\ --header 'Authorization: Bearer &lt;access_token&gt;' Replace &lt;access_token&gt; with the previously stored access token. You should get a 200 OK JSON response with the requested resource in the body. Test user authentication flow Step 1: Fail to fetch protected API content Try to view your admin account by executing: curl --location 'https://api.dotkernel.net/user/my-account' You should get a 403 Forbidden JSON response. Step 2: Generate access token Generate admin access token by executing: curl --location 'https://api.dotkernel.net/security/generate-token' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"test@dotkernel.com\", \"password\": \"dotkernel\" }' You should get a 200 OK JSON response. Store the value of access_token for later use. Step 3: Successfully fetch protected API content Try again viewing your admin account by executing: curl --location 'https://api.dotkernel.net/user/my-account' \\ --header 'Authorization: Bearer &lt;access_token&gt;' Replace &lt;access_token&gt; with the previously stored access token. You should get a 200 OK JSON response with the requested resource in the body.","title":"Token authentication"},{"location":"v5/tutorials/token-authentication/#token-authentication","text":"","title":"Token authentication"},{"location":"v5/tutorials/token-authentication/#what-is-token-authentication","text":"Token authentication means making a request to an API endpoint while also sending a special header that contains an access token. The access token was previously generated by (usually) the same API as the one you are sending requests to and it consists of an alphanumeric string.","title":"What is token authentication?"},{"location":"v5/tutorials/token-authentication/#how-does-it-work","text":"In order to protect specific resources, clients need to be authenticated with user/admin roles. These roles are identified from the access token sent via the Authorization header. When DotKernel API receives a request, it tries to read the access token. If it does not find an access token, client has guest role: if the requested endpoint needs no authentication, the requested resource is returned else, a 403 Forbidden response is returned Else, client's account is identified and client has admin / user role (the one assigned in their account) if the requested endpoint is accessible to the client, the requested resource is returned else, a 403 Forbidden response is returned DotKernel API provides out-of-the-box both an admin and a user account. The admin account with role set to both superuser and admin with the following credentials: identity : admin password : dotkernel The user account with role set to both user and guest with the following credentials: identify : test@dotkernel.com password : dotkernel","title":"How does it work?"},{"location":"v5/tutorials/token-authentication/#flow","text":"client sends API request with credentials API returns a JSON object containing a new access and refresh token client sends API request using Authentication header containing the previously generated access token API returns requested resource","title":"Flow"},{"location":"v5/tutorials/token-authentication/#generate-admin-access-token","text":"Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" }","title":"Generate admin access token"},{"location":"v5/tutorials/token-authentication/#generate-user-access-token","text":"Send a POST request to the /security/generate-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"password\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"username\": \"&lt;identity&gt;\", \"password\": \"&lt;password&gt;\" }","title":"Generate user access token"},{"location":"v5/tutorials/token-authentication/#refresh-admin-access-token","text":"Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"admin\", \"client_secret\": \"admin\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }","title":"Refresh admin access token"},{"location":"v5/tutorials/token-authentication/#refresh-user-access-token","text":"Send a POST request to the /security/refresh-token endpoint with Content-Type header set to application/json . Set request body to: { \"grant_type\": \"refresh_token\", \"client_id\": \"frontend\", \"client_secret\": \"frontend\", \"scope\": \"api\", \"refresh_token\": \"&lt;refresh-token&gt;\" }","title":"Refresh user access token"},{"location":"v5/tutorials/token-authentication/#test-admin-authentication-flow","text":"","title":"Test admin authentication flow"},{"location":"v5/tutorials/token-authentication/#test-user-authentication-flow","text":"","title":"Test user authentication flow"}]}
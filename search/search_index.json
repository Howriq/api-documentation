{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../../README.md","title":"Home"},{"location":"#readmemd","text":"","title":"../../README.md"},{"location":"v4/core-features/content-validation/","text":"Content Negotiation Content Negotiation is performed by an application in order : To match the requested representation as specified by the client via the Accept header with a representation the application can deliver. To determine the Content-Type of incoming data and deserialize it so the application can utilize it. Essentially, content negotiation is the client telling the server what it is sending and what it wants in return, and the server determining if it can do what the client requests. Content negotiation validation in DotKernel API happened through middleware, and it ensures that the incoming request and the outgoing response conform to the content types specified in the config file for all routes or for a specific route. It performs validation on the Accept and Content-Type headers of the request and response and returning appropriate errors responses when necessary. Configuration In DotKernel the configuration file for content negotiation is held on config/autoload/content-negotiation.global.php and the array look like this: return [ 'content-negotiation' =&gt; [ 'default' =&gt; [ 'Accept' =&gt; [ 'application/json', 'application/hal+json', ], 'Content-Type' =&gt; [ 'application/json', 'application/hal+json', ], ], 'your.route.name' =&gt; [ 'Accept' =&gt; [], 'Content-Type' =&gt; [], ], ], ]; Except the default key, all your key must match the route name, for example in DotKernel we have the route to list all admins, which name is admin.list . If you did not specify a route name to configure you specifications about content negotiation, the default one will be in place. The default key is mandatory . Every route configuration must come with Accept and Content-Type keys, basically this will be the keys that the request headers will be validated against. Accept Negotiation This specifies that your server can return that representation, or at least one the representation send from the client GET /admin HTTP/1.1 Accept: application/json This request indicates the client wants application/json in return. Now the server, through the config file will try to validate if that representation can be returned, basically if application/json is presented in the Accept key. If the representation cannot be returned, a status code 406 - Not Acceptable will be returned. If the representation can be returned, the server should report the media type through Content-Type header of the response. Due to how these validations are make, for a json media type, the server can return a more generic media type, for example, if the clients send Accept: application/vnd.api+json and you configured your Accept key as application/json the representation will be returned as is still json. If the Accept header of the request contains */* it means that whatever the server can return is OK, so it can return anything Content-Type Negotiation This aspect of content negotiation is the Content-Type key and determining if the server can deserialize the data. POST /admin/1 HTTP/1.1 Accept: application/json Content-Type: application/json { \"foo\": \"bar\" } The server will try to validate this Content-Type against your configured Content-Type key from the config file, and if the format is not supported, a status code 415 - Unsupported Media Type will be returned. For example, you have a route that it needs an upload file, normally you will configure the Content-Type of that route to be multipart/form-data . The above request will fail as the client send application/json as Content-Type If the request does not contain \"Content-Type\" header, that means that the server will try to deserialize tha data as he can. The Request &lt;-&gt; Response validation In addition to the validation described above, a third one is happening and is the last one, the server will check if the request Accept header can really be returned by the response. Through how the DotKernel API is returning a response in handler , a content type is always set, but this cannot be the case in any custom response but in any way the server will check what Content-Type the response is returning and will try to validate that against the Accept header of the request. If the validation fails, a status code 406 - Not Acceptable will be returned.","title":"Content Validation"},{"location":"v4/core-features/content-validation/#content-negotiation","text":"Content Negotiation is performed by an application in order : To match the requested representation as specified by the client via the Accept header with a representation the application can deliver. To determine the Content-Type of incoming data and deserialize it so the application can utilize it. Essentially, content negotiation is the client telling the server what it is sending and what it wants in return, and the server determining if it can do what the client requests. Content negotiation validation in DotKernel API happened through middleware, and it ensures that the incoming request and the outgoing response conform to the content types specified in the config file for all routes or for a specific route. It performs validation on the Accept and Content-Type headers of the request and response and returning appropriate errors responses when necessary.","title":"Content Negotiation"},{"location":"v4/core-features/content-validation/#configuration","text":"In DotKernel the configuration file for content negotiation is held on config/autoload/content-negotiation.global.php and the array look like this: return [ 'content-negotiation' =&gt; [ 'default' =&gt; [ 'Accept' =&gt; [ 'application/json', 'application/hal+json', ], 'Content-Type' =&gt; [ 'application/json', 'application/hal+json', ], ], 'your.route.name' =&gt; [ 'Accept' =&gt; [], 'Content-Type' =&gt; [], ], ], ]; Except the default key, all your key must match the route name, for example in DotKernel we have the route to list all admins, which name is admin.list . If you did not specify a route name to configure you specifications about content negotiation, the default one will be in place. The default key is mandatory . Every route configuration must come with Accept and Content-Type keys, basically this will be the keys that the request headers will be validated against.","title":"Configuration"},{"location":"v4/core-features/content-validation/#accept-negotiation","text":"This specifies that your server can return that representation, or at least one the representation send from the client GET /admin HTTP/1.1 Accept: application/json This request indicates the client wants application/json in return. Now the server, through the config file will try to validate if that representation can be returned, basically if application/json is presented in the Accept key. If the representation cannot be returned, a status code 406 - Not Acceptable will be returned. If the representation can be returned, the server should report the media type through Content-Type header of the response. Due to how these validations are make, for a json media type, the server can return a more generic media type, for example, if the clients send Accept: application/vnd.api+json and you configured your Accept key as application/json the representation will be returned as is still json. If the Accept header of the request contains */* it means that whatever the server can return is OK, so it can return anything","title":"Accept Negotiation"},{"location":"v4/core-features/content-validation/#content-type-negotiation","text":"This aspect of content negotiation is the Content-Type key and determining if the server can deserialize the data. POST /admin/1 HTTP/1.1 Accept: application/json Content-Type: application/json { \"foo\": \"bar\" } The server will try to validate this Content-Type against your configured Content-Type key from the config file, and if the format is not supported, a status code 415 - Unsupported Media Type will be returned. For example, you have a route that it needs an upload file, normally you will configure the Content-Type of that route to be multipart/form-data . The above request will fail as the client send application/json as Content-Type If the request does not contain \"Content-Type\" header, that means that the server will try to deserialize tha data as he can.","title":"Content-Type Negotiation"},{"location":"v4/core-features/content-validation/#the-request-response-validation","text":"In addition to the validation described above, a third one is happening and is the last one, the server will check if the request Accept header can really be returned by the response. Through how the DotKernel API is returning a response in handler , a content type is always set, but this cannot be the case in any custom response but in any way the server will check what Content-Type the response is returning and will try to validate that against the Accept header of the request. If the validation fails, a status code 406 - Not Acceptable will be returned.","title":"The Request &lt;-&gt; Response validation"},{"location":"v4/core-features/exceptions/","text":"Exceptions [WIP] https://github.com/dotkernel/api/pull/269/files# src/App/src/Handler/ResponseTrait.php","title":"Exceptions"},{"location":"v4/core-features/exceptions/#exceptions-wip","text":"https://github.com/dotkernel/api/pull/269/files# src/App/src/Handler/ResponseTrait.php","title":"Exceptions [WIP]"},{"location":"v4/flow/default-library-flow/","text":"Default Library Flow The graph below demonstrates a default flow between DotKernel's libraries.","title":"Default Library Flow"},{"location":"v4/flow/default-library-flow/#default-library-flow","text":"The graph below demonstrates a default flow between DotKernel's libraries.","title":"Default Library Flow"},{"location":"v4/flow/library-flow-for-email/","text":"Library Flow for Email The graph below demonstrates the simplified flow between DotKernel's libraries for sending an email.","title":"Library Flow for Email"},{"location":"v4/flow/library-flow-for-email/#library-flow-for-email","text":"The graph below demonstrates the simplified flow between DotKernel's libraries for sending an email.","title":"Library Flow for Email"},{"location":"v4/flow/middleware-flow/","text":"Middleware flow The graph below demonstrates a default flow between DotKernel's middlewares.","title":"Middleware Flow"},{"location":"v4/flow/middleware-flow/#middleware-flow","text":"The graph below demonstrates a default flow between DotKernel's middlewares.","title":"Middleware flow"},{"location":"v4/installation/composer/","text":"Composer Installation of Packages Install dependencies composer install Development mode If you're installing the project for development, make sure you have development mode enabled, by running: composer development-enable You can disable development mode by running: composer development-disable You can check if you have development mode enabled by running: composer development-status","title":"Composer"},{"location":"v4/installation/composer/#composer-installation-of-packages","text":"","title":"Composer Installation of Packages"},{"location":"v4/installation/composer/#install-dependencies","text":"composer install","title":"Install dependencies"},{"location":"v4/installation/composer/#development-mode","text":"If you're installing the project for development, make sure you have development mode enabled, by running: composer development-enable You can disable development mode by running: composer development-disable You can check if you have development mode enabled by running: composer development-status","title":"Development mode"},{"location":"v4/installation/configuration-files/","text":"Configuration Files Prepare config files duplicate config/autoload/cors.local.php.dist as config/autoload/cors.local.php Note if your API will be consumed by another application, make sure to configure the allowed_origins variable duplicate config/autoload/local.php.dist as config/autoload/local.php duplicate config/autoload/mail.local.php.dist as config/autoload/mail.local.php Note if your API will send emails, make sure to fill in SMTP connection params optional : in order to run/create tests, duplicate config/autoload/local.test.php.dist as config/autoload/local.test.php Note this creates a new in-memory database that your tests will run on.","title":"Configuration Files"},{"location":"v4/installation/configuration-files/#configuration-files","text":"","title":"Configuration Files"},{"location":"v4/installation/configuration-files/#prepare-config-files","text":"duplicate config/autoload/cors.local.php.dist as config/autoload/cors.local.php","title":"Prepare config files"},{"location":"v4/installation/doctrine-orm/","text":"Doctrine ORM Setup database Make sure you fill out the database credentials in config/autoload/local.php under $databases['default'] . Create a new MySQL database - set collation to utf8mb4_general_ci Running migrations Run the database migrations by using the following command: php vendor/bin/doctrine-migrations migrate This command will prompt you to confirm that you want to run it. WARNING! You are about to execute a migration in database \"...\" that could result in schema changes and data loss. Are you sure you wish to continue? (yes/no) [yes]: Hit Enter to confirm the operation. Executing fixtures Fixtures are used to seed the database with initial values and should be executed after migrating the database. To list all the fixtures, run: php bin/doctrine fixtures:list This will output all the fixtures in the order of execution. To execute all fixtures, run: php bin/doctrine fixtures:execute To execute a specific fixture, run: php bin/doctrine fixtures:execute --class=FixtureClassName More details on how fixtures work can be found here: https://github.com/dotkernel/dot-data-fixtures#creating-fixtures","title":"Doctrine ORM"},{"location":"v4/installation/doctrine-orm/#doctrine-orm","text":"","title":"Doctrine ORM"},{"location":"v4/installation/doctrine-orm/#setup-database","text":"Make sure you fill out the database credentials in config/autoload/local.php under $databases['default'] . Create a new MySQL database - set collation to utf8mb4_general_ci","title":"Setup database"},{"location":"v4/installation/doctrine-orm/#running-migrations","text":"Run the database migrations by using the following command: php vendor/bin/doctrine-migrations migrate This command will prompt you to confirm that you want to run it. WARNING! You are about to execute a migration in database \"...\" that could result in schema changes and data loss. Are you sure you wish to continue? (yes/no) [yes]: Hit Enter to confirm the operation.","title":"Running migrations"},{"location":"v4/installation/doctrine-orm/#executing-fixtures","text":"Fixtures are used to seed the database with initial values and should be executed after migrating the database. To list all the fixtures, run: php bin/doctrine fixtures:list This will output all the fixtures in the order of execution. To execute all fixtures, run: php bin/doctrine fixtures:execute To execute a specific fixture, run: php bin/doctrine fixtures:execute --class=FixtureClassName More details on how fixtures work can be found here: https://github.com/dotkernel/dot-data-fixtures#creating-fixtures","title":"Executing fixtures"},{"location":"v4/installation/faq/","text":"Frequently Asked Questions How do I fix common permission issues? If running your project you encounter some permission issues, follow the below steps. Errors PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data\" is not writable... PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data/cache\" is not writable... PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/data/cache/doctrine\" is not writable... Fix: chmod -R 777 data Error PHP Fatal error: Uncaught InvalidArgumentException: The directory \"/var/www/ example.local /html/public/uploads\" is not writable... Fix: chmod -R 777 public/uploads Error PHP Fatal error: Uncaught ErrorException: fopen(/var/www/ example.local /config/autoload/../../log/error-log- yyyy-mm-dd.log ): Failed to open stream: Permission denied... Fix: chmod -R 777 log","title":"FAQ"},{"location":"v4/installation/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"v4/installation/faq/#how-do-i-fix-common-permission-issues","text":"If running your project you encounter some permission issues, follow the below steps.","title":"How do I fix common permission issues?"},{"location":"v4/installation/getting-started/","text":"Clone the project Using your terminal, navigate inside the directory you want to download the project files into. Make sure that the directory is empty before proceeding to the download process. Once there, run the following command: git clone https://github.com/dotkernel/api.git .","title":"Getting Started"},{"location":"v4/installation/getting-started/#clone-the-project","text":"Using your terminal, navigate inside the directory you want to download the project files into. Make sure that the directory is empty before proceeding to the download process. Once there, run the following command: git clone https://github.com/dotkernel/api.git .","title":"Clone the project"},{"location":"v4/installation/test-the-installation/","text":"Test the installation Sending a GET request to the home page should output the following message: {\"message\": \"Welcome to DotKernel API!\"} Old way of doing things, using PHP built-in server php -S 0.0.0.0:8080 -t public Running tests The project has 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit Running unit tests vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always Running functional tests vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Test the Installation"},{"location":"v4/installation/test-the-installation/#test-the-installation","text":"Sending a GET request to the home page should output the following message: {\"message\": \"Welcome to DotKernel API!\"}","title":"Test the installation"},{"location":"v4/installation/test-the-installation/#old-way-of-doing-things-using-php-built-in-server","text":"php -S 0.0.0.0:8080 -t public","title":"Old way of doing things, using PHP built-in server"},{"location":"v4/installation/test-the-installation/#running-tests","text":"The project has 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit","title":"Running tests"},{"location":"v4/installation/test-the-installation/#running-unit-tests","text":"vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always","title":"Running unit tests"},{"location":"v4/installation/test-the-installation/#running-functional-tests","text":"vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Running functional tests"},{"location":"v4/introduction/file-structure/","text":"File structure Dotkernel API follows the PSR-4 standards. It is a good practice to standardize the file structure of projects. When using DotKernel API the following structure is installed by default: Main directories bin - executable files from CLI config - various configuration files data - should contain project-related data (AVOID storing sensitive data on VCS) documentation - should contain project-related documentation log - storage of log files generated by dot-error-log library public - publicly visible files. The webserver need to have this folder as www-document root folder. src - should contain the source code files test - should contain the test files Special purpose folders .github - containes workflow files .laminas-ci - contains laminas-ci workflow files src directory This directory contains all source code related to the Module. It should contain following directories, if they’re not empty: Handler - Action classes (similar to Controllers but can only perform one action) Entity - For database entities Service - Service classes Collection - Database entities collections Repository - Entity repository folder The above example is just some of the directories a project may include, but these should give you an idea of how the structure should look like. Other classes in the src directory may include InputFilter , EventListener , Helper , Command , Factory etc. The src directory should also contain 2 files: ConfigProvider.php - Provides configuration data RoutesDelegator.php - Module main routes entry file templates directory This directory contains the template files, used for example to help render e-mail templates. DotKernel API uses twig as Templating Engine. All template files have the extension .html.twig data directory This directory contains project-related data (such as cache, file uploads) We recommend using the following directory structure: data/cache - location where caches are stored data/oauth - encryption, private and public keys needed for authentication. data/doctrine - fixtures and migrations data/lock - lock files generated by dotkernel/dot-cli See more","title":"File Structure"},{"location":"v4/introduction/file-structure/#file-structure","text":"Dotkernel API follows the PSR-4 standards. It is a good practice to standardize the file structure of projects. When using DotKernel API the following structure is installed by default:","title":"File structure"},{"location":"v4/introduction/file-structure/#main-directories","text":"bin - executable files from CLI config - various configuration files data - should contain project-related data (AVOID storing sensitive data on VCS) documentation - should contain project-related documentation log - storage of log files generated by dot-error-log library public - publicly visible files. The webserver need to have this folder as www-document root folder. src - should contain the source code files test - should contain the test files","title":"Main directories"},{"location":"v4/introduction/file-structure/#special-purpose-folders","text":".github - containes workflow files .laminas-ci - contains laminas-ci workflow files","title":"Special purpose folders"},{"location":"v4/introduction/file-structure/#src-directory","text":"This directory contains all source code related to the Module. It should contain following directories, if they’re not empty: Handler - Action classes (similar to Controllers but can only perform one action) Entity - For database entities Service - Service classes Collection - Database entities collections Repository - Entity repository folder The above example is just some of the directories a project may include, but these should give you an idea of how the structure should look like. Other classes in the src directory may include InputFilter , EventListener , Helper , Command , Factory etc. The src directory should also contain 2 files: ConfigProvider.php - Provides configuration data RoutesDelegator.php - Module main routes entry file","title":"src directory"},{"location":"v4/introduction/file-structure/#templates-directory","text":"This directory contains the template files, used for example to help render e-mail templates. DotKernel API uses twig as Templating Engine. All template files have the extension .html.twig","title":"templates directory"},{"location":"v4/introduction/file-structure/#data-directory","text":"This directory contains project-related data (such as cache, file uploads) We recommend using the following directory structure: data/cache - location where caches are stored data/oauth - encryption, private and public keys needed for authentication. data/doctrine - fixtures and migrations data/lock - lock files generated by dotkernel/dot-cli See more","title":"data directory"},{"location":"v4/introduction/introduction/","text":"Introduction Based on Enrico Zimuel’s Zend Expressive API – Skeleton example, DotKernel API runs on Laminas and Mezzio components and implements standards like PSR-3, PSR-4, PSR-7, PSR-11 and PSR-15. Here is a list of the core components: Middleware Microframework (mezzio/mezzio) Error Handler (dotkernel/dot-errorhandler) Problem Details (mezzio/mezzio-problem-details) CORS (mezzio/mezzio-cors) Routing (mezzio/mezzio-fastroute) Authentication (mezzio/mezzio-authentication) Authorization (mezzio/mezzio-authorization) Config Aggregator (laminas/laminas-config-aggregator) Container (roave/psr-container-doctrine) Annotations (dotkernel/dot-annotated-services) Input Filter (laminas/laminas-inputfilter) Doctrine 2 ORM (doctrine/orm) Serializer/Deserializer (laminas/laminas-hydrator) Paginator (laminas/laminas-paginator) HAL (mezzio/mezzio-hal) CLI (dotkernel/dot-cli) TwigRenderer (mezzio/mezzio-twigrenderer) Fixtures (dotkernel/dot-data-fixtures) UUID (ramsey/uuid-doctrine) Doctrine 2 ORM For the persistence in a relational database management system we chose Doctrine ORM (object-relational mapper). The benefit of Doctrine for the programmer is the ability to focus on the object-oriented business logic and worry about persistence only as a secondary priority. Documentation Our documentation is Postman based. We use the following files in which we store information about every available endpoint ready to be tested: documentation/DotKernel_API.postman_collection.json documentation/DotKernel_API.postman_environment.json Hypertext Application Language For our API payloads (a value object for describing the API resource, its relational links and any embedded/child resources related to it) we chose mezzio-hal. CORS By using MezzioCorsMiddlewareCorsMiddleware , the CORS preflight will be recognized and the middleware will start to detect the proper CORS configuration. The Router is used to detect every allowed request method by executing a route match with all possible request methods. Therefore, for every preflight request, there is at least one Router request. OAuth 2.0 OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on your DotKernel API. We are using mezzio/mezzio-authentication-oauth2 which provides OAuth 2.0 authentication for Mezzio and PSR-7/PSR-15 applications by using league/oauth2-server package. Email It is not unlikely for an API to send emails depending on the use case. Here is another area where DotKernel API shines. Using DotMailServiceMailService provided by dotkernel/dot-mail you can easily send custom email templates. Configuration From authorization at request route level to API keys for your application, you can find every configuration variable in the config directory. Registering a new module can be done by including its ConfigProvider.php in config.php. Brand new middlewares should go into pipeline.php. Here you can edit the order in which they run and find more info about the currently included ones. You can further customize your api within the autoload directory where each configuration category has its own file. Routing Each module has a RoutesDelegator.php file for managing existing routes inside that specific module. It also allows a quick way of adding new routes by providing the route path, Middlewares that the route will use and the route name. You can allocate permissions per route name in order to restrict access for a user role to a specific route in config/autoload/authorization.global.php . Commands For registering new commands first make sure your command class extends SymfonyComponentConsoleCommandCommand . Then you can enable it by registering it in config/autoload/cli.global.php . File locker Here you will also find our brand-new file locker configuration, so you can easily turn it on or off (by default: 'enabled' =&gt; true ). Note: The File Locker System will create a command-{command-default-name}.lock file which will not let another instance of the same command to run until the previous one has finished. PSR Standards PSR-3 : Logger Interface – the application uses LoggerInterface for error logging PSR-4 : Autoloader – the application locates classes using an autoloader PSR-7 : HTTP message interfaces – the handlers return ResponseInterface PSR-11 : Container interface – the application is container-based PSR-15 : HTTP Server Request Handlers – the handlers implement RequestHandlerInterface Tests One of the best ways to ensure the quality of your product is to create and run functional and unit tests. You can find factory-made tests in the tests/AppTest/ folder, and you can also register your own. We have 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit Running unit tests vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always Running functional tests vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Introduction"},{"location":"v4/introduction/introduction/#introduction","text":"Based on Enrico Zimuel’s Zend Expressive API – Skeleton example, DotKernel API runs on Laminas and Mezzio components and implements standards like PSR-3, PSR-4, PSR-7, PSR-11 and PSR-15. Here is a list of the core components: Middleware Microframework (mezzio/mezzio) Error Handler (dotkernel/dot-errorhandler) Problem Details (mezzio/mezzio-problem-details) CORS (mezzio/mezzio-cors) Routing (mezzio/mezzio-fastroute) Authentication (mezzio/mezzio-authentication) Authorization (mezzio/mezzio-authorization) Config Aggregator (laminas/laminas-config-aggregator) Container (roave/psr-container-doctrine) Annotations (dotkernel/dot-annotated-services) Input Filter (laminas/laminas-inputfilter) Doctrine 2 ORM (doctrine/orm) Serializer/Deserializer (laminas/laminas-hydrator) Paginator (laminas/laminas-paginator) HAL (mezzio/mezzio-hal) CLI (dotkernel/dot-cli) TwigRenderer (mezzio/mezzio-twigrenderer) Fixtures (dotkernel/dot-data-fixtures) UUID (ramsey/uuid-doctrine)","title":"Introduction"},{"location":"v4/introduction/introduction/#doctrine-2-orm","text":"For the persistence in a relational database management system we chose Doctrine ORM (object-relational mapper). The benefit of Doctrine for the programmer is the ability to focus on the object-oriented business logic and worry about persistence only as a secondary priority.","title":"Doctrine 2 ORM"},{"location":"v4/introduction/introduction/#documentation","text":"Our documentation is Postman based. We use the following files in which we store information about every available endpoint ready to be tested: documentation/DotKernel_API.postman_collection.json documentation/DotKernel_API.postman_environment.json","title":"Documentation"},{"location":"v4/introduction/introduction/#hypertext-application-language","text":"For our API payloads (a value object for describing the API resource, its relational links and any embedded/child resources related to it) we chose mezzio-hal.","title":"Hypertext Application Language"},{"location":"v4/introduction/introduction/#cors","text":"By using MezzioCorsMiddlewareCorsMiddleware , the CORS preflight will be recognized and the middleware will start to detect the proper CORS configuration. The Router is used to detect every allowed request method by executing a route match with all possible request methods. Therefore, for every preflight request, there is at least one Router request.","title":"CORS"},{"location":"v4/introduction/introduction/#oauth-20","text":"OAuth 2.0 is an authorization framework that enables applications to obtain limited access to user accounts on your DotKernel API. We are using mezzio/mezzio-authentication-oauth2 which provides OAuth 2.0 authentication for Mezzio and PSR-7/PSR-15 applications by using league/oauth2-server package.","title":"OAuth 2.0"},{"location":"v4/introduction/introduction/#email","text":"It is not unlikely for an API to send emails depending on the use case. Here is another area where DotKernel API shines. Using DotMailServiceMailService provided by dotkernel/dot-mail you can easily send custom email templates.","title":"Email"},{"location":"v4/introduction/introduction/#configuration","text":"From authorization at request route level to API keys for your application, you can find every configuration variable in the config directory. Registering a new module can be done by including its ConfigProvider.php in config.php. Brand new middlewares should go into pipeline.php. Here you can edit the order in which they run and find more info about the currently included ones. You can further customize your api within the autoload directory where each configuration category has its own file.","title":"Configuration"},{"location":"v4/introduction/introduction/#routing","text":"Each module has a RoutesDelegator.php file for managing existing routes inside that specific module. It also allows a quick way of adding new routes by providing the route path, Middlewares that the route will use and the route name. You can allocate permissions per route name in order to restrict access for a user role to a specific route in config/autoload/authorization.global.php .","title":"Routing"},{"location":"v4/introduction/introduction/#commands","text":"For registering new commands first make sure your command class extends SymfonyComponentConsoleCommandCommand . Then you can enable it by registering it in config/autoload/cli.global.php .","title":"Commands"},{"location":"v4/introduction/introduction/#file-locker","text":"Here you will also find our brand-new file locker configuration, so you can easily turn it on or off (by default: 'enabled' =&gt; true ). Note: The File Locker System will create a command-{command-default-name}.lock file which will not let another instance of the same command to run until the previous one has finished.","title":"File locker"},{"location":"v4/introduction/introduction/#psr-standards","text":"PSR-3 : Logger Interface – the application uses LoggerInterface for error logging PSR-4 : Autoloader – the application locates classes using an autoloader PSR-7 : HTTP message interfaces – the handlers return ResponseInterface PSR-11 : Container interface – the application is container-based PSR-15 : HTTP Server Request Handlers – the handlers implement RequestHandlerInterface","title":"PSR Standards"},{"location":"v4/introduction/introduction/#tests","text":"One of the best ways to ensure the quality of your product is to create and run functional and unit tests. You can find factory-made tests in the tests/AppTest/ folder, and you can also register your own. We have 2 types of tests: functional and unit tests, you can run both types at the same type by executing this command: php vendor/bin/phpunit","title":"Tests"},{"location":"v4/introduction/introduction/#running-unit-tests","text":"vendor/bin/phpunit --testsuite=UnitTests --testdox --colors=always","title":"Running unit tests"},{"location":"v4/introduction/introduction/#running-functional-tests","text":"vendor/bin/phpunit --testsuite=FunctionalTests --testdox --colors=always","title":"Running functional tests"},{"location":"v4/introduction/packages/","text":"Packages dotkernel/dot-annotated-services - Dependency injection component using class attributes. dotkernel/dot-cache - Cache component extending symfony-cache dotkernel/dot-cli - Component for creating console applications based on laminas-cli dotkernel/dot-data-fixtures - Provides a CLI interface for listing &amp; executing doctrine data fixtures dotkernel/dot-errorhandler - Logging Error Handler for Middleware Applications dotkernel/dot-mail - Mail component based on laminas-mail dotkernel/dot-response-header - Middleware for setting custom response headers. laminas/laminas-component-installer - Composer plugin for injecting modules and configuration providers into application configuration laminas/laminas-config - Provides a nested object property based user interface for accessing this configuration data within application code laminas/laminas-config-aggregator - Lightweight library for collecting and merging configuration from different sources laminas/laminas-http - Provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests laminas/laminas-hydrator - Serialize objects to arrays, and vice versa laminas/laminas-inputfilter - Normalize and validate input sets from the web, APIs, the CLI, and more, including files laminas/laminas-paginator - Paginate collections of data from arbitrary sources laminas/laminas-stdlib - SPL extensions, array utilities, error handlers, and more laminas/laminas-text - Create FIGlets and text-based tables mezzio/mezzio - PSR-15 Middleware Microframework mezzio/mezzio-authentication-oauth2 - OAuth2 (server) authentication middleware for Mezzio and PSR-7 applications mezzio/mezzio-authorization-acl - laminas-permissions-acl adapter for mezzio-authorization mezzio/mezzio-authorization-rbac - mezzio authorization rbac adapter for laminas/laminas-permissions-rbac mezzio/mezzio-cors - CORS component for Mezzio and other PSR-15 middleware runners mezzio/mezzio-fastroute - FastRoute integration for Mezzio mezzio/mezzio-hal - Hypertext Application Language implementation for PHP and PSR-7 mezzio/mezzio-problem-details - Problem Details for PSR-7 HTTP APIs addressing the RFC 7807 standard mezzio/mezzio-twigrenderer - Twig integration for Mezzio ramsey/uuid-doctrine - Use ramsey/uuid as a Doctrine field type roave/psr-container-doctrine - Doctrine Factories for PSR-11 Containers symfony/filesystem - Provides basic utilities for the filesystem","title":"Packages"},{"location":"v4/introduction/packages/#packages","text":"dotkernel/dot-annotated-services - Dependency injection component using class attributes. dotkernel/dot-cache - Cache component extending symfony-cache dotkernel/dot-cli - Component for creating console applications based on laminas-cli dotkernel/dot-data-fixtures - Provides a CLI interface for listing &amp; executing doctrine data fixtures dotkernel/dot-errorhandler - Logging Error Handler for Middleware Applications dotkernel/dot-mail - Mail component based on laminas-mail dotkernel/dot-response-header - Middleware for setting custom response headers. laminas/laminas-component-installer - Composer plugin for injecting modules and configuration providers into application configuration laminas/laminas-config - Provides a nested object property based user interface for accessing this configuration data within application code laminas/laminas-config-aggregator - Lightweight library for collecting and merging configuration from different sources laminas/laminas-http - Provides an easy interface for performing Hyper-Text Transfer Protocol (HTTP) requests laminas/laminas-hydrator - Serialize objects to arrays, and vice versa laminas/laminas-inputfilter - Normalize and validate input sets from the web, APIs, the CLI, and more, including files laminas/laminas-paginator - Paginate collections of data from arbitrary sources laminas/laminas-stdlib - SPL extensions, array utilities, error handlers, and more laminas/laminas-text - Create FIGlets and text-based tables mezzio/mezzio - PSR-15 Middleware Microframework mezzio/mezzio-authentication-oauth2 - OAuth2 (server) authentication middleware for Mezzio and PSR-7 applications mezzio/mezzio-authorization-acl - laminas-permissions-acl adapter for mezzio-authorization mezzio/mezzio-authorization-rbac - mezzio authorization rbac adapter for laminas/laminas-permissions-rbac mezzio/mezzio-cors - CORS component for Mezzio and other PSR-15 middleware runners mezzio/mezzio-fastroute - FastRoute integration for Mezzio mezzio/mezzio-hal - Hypertext Application Language implementation for PHP and PSR-7 mezzio/mezzio-problem-details - Problem Details for PSR-7 HTTP APIs addressing the RFC 7807 standard mezzio/mezzio-twigrenderer - Twig integration for Mezzio ramsey/uuid-doctrine - Use ramsey/uuid as a Doctrine field type roave/psr-container-doctrine - Doctrine Factories for PSR-11 Containers symfony/filesystem - Provides basic utilities for the filesystem","title":"Packages"},{"location":"v4/introduction/server-requirements/","text":"Server Requirements For production, we highly recommend a *nix based system. Webserver Apache &gt;= 2.2 or Nginx mod_rewrite .htaccess support (AllowOverride All) PHP &gt;= 8.2 Both mod_php and FCGI (FPM) are supported. Required Settings and Modules &amp; Extensions memory_limit &gt;= 128M upload_max_filesize and post_max_size &gt;= 100M (depending on your data) mbstring CLI SAPI (for Cron Jobs) Composer (added to $PATH) RDBMS MySQL / MariaDB &gt;= 5.5.3 Recommended extensions opcache pdo_mysql or mysqli (if using MySQL or MariaDB as RDBMS) dom - if working with markup files structure (html, xml, etc) simplexml - working with xml files gd, exif - if working with images zlib, zip, bz2 - if compessing files curl (required if APIs are used)","title":"Server Requirements"},{"location":"v4/introduction/server-requirements/#server-requirements","text":"For production, we highly recommend a *nix based system.","title":"Server Requirements"},{"location":"v4/introduction/server-requirements/#webserver","text":"Apache &gt;= 2.2 or Nginx mod_rewrite .htaccess support (AllowOverride All)","title":"Webserver"},{"location":"v4/introduction/server-requirements/#php-82","text":"Both mod_php and FCGI (FPM) are supported.","title":"PHP &gt;= 8.2"},{"location":"v4/introduction/server-requirements/#required-settings-and-modules-extensions","text":"memory_limit &gt;= 128M upload_max_filesize and post_max_size &gt;= 100M (depending on your data) mbstring CLI SAPI (for Cron Jobs) Composer (added to $PATH)","title":"Required Settings and Modules &amp; Extensions"},{"location":"v4/introduction/server-requirements/#rdbms","text":"MySQL / MariaDB &gt;= 5.5.3","title":"RDBMS"},{"location":"v4/introduction/server-requirements/#recommended-extensions","text":"opcache pdo_mysql or mysqli (if using MySQL or MariaDB as RDBMS) dom - if working with markup files structure (html, xml, etc) simplexml - working with xml files gd, exif - if working with images zlib, zip, bz2 - if compessing files curl (required if APIs are used)","title":"Recommended extensions"},{"location":"v4/transition-from-api-tools/api-tools-vs-dotkernel-api/","text":"Laminas API Tools compared to DotKernel API API Tools (formerly Apigility) DotKernel API URL api-tools Dotkernel API First Release 2012 2018 PHP Version &lt;= 8.2 &gt;= 8.1 Architecture MVC, Event Driven Middleware OSS Lifecycle Archived Style REST, RPC REST Versioning Yes Deprecations * Documentation Swagger (Automated) Postman (Manual) * Content-Negotiation Custom Custom License BSD-3 MIT Default DB Layer laminas-db doctrine-orm Authorization ACL RBAC-guard Authentication HTTP Basic/Digest OAuth2.0 OAuth2.0 CI/CD Yes Yes Unit Tests Yes Yes Endpoint Generator Yes Under development PSR PSR-7 PSR-7, PSR-15 Note Versioning is replaced by Deprecations, using evolution strategy Version 5 ( Roadmap ) will implement OpenAPi 3.0","title":"Laminas API Tools vs DotKernel API"},{"location":"v4/transition-from-api-tools/api-tools-vs-dotkernel-api/#laminas-api-tools-compared-to-dotkernel-api","text":"API Tools (formerly Apigility) DotKernel API URL api-tools Dotkernel API First Release 2012 2018 PHP Version &lt;= 8.2 &gt;= 8.1 Architecture MVC, Event Driven Middleware OSS Lifecycle Archived Style REST, RPC REST Versioning Yes Deprecations * Documentation Swagger (Automated) Postman (Manual) * Content-Negotiation Custom Custom License BSD-3 MIT Default DB Layer laminas-db doctrine-orm Authorization ACL RBAC-guard Authentication HTTP Basic/Digest OAuth2.0 OAuth2.0 CI/CD Yes Yes Unit Tests Yes Yes Endpoint Generator Yes Under development PSR PSR-7 PSR-7, PSR-15","title":"Laminas API Tools compared to DotKernel API"},{"location":"v4/transition-from-api-tools/api-tools-vs-dotkernel-api/#note","text":"Versioning is replaced by Deprecations, using evolution strategy Version 5 ( Roadmap ) will implement OpenAPi 3.0","title":"Note"},{"location":"v4/transition-from-api-tools/discovery-phase/","text":"Discovery phase for a current system built using API Tools [WIP] In order to transition a system built using api-tools to Dotkernel API , we need to analyze the core components of it. Database there is a database in the current API ? which is the connection to database which library is used for database interaction ( laminas-db, doctrine 2, eloquent, or else ) Note Dotkernel API is tested only with MariaDB version 10.6 and 10.11 LTS Authentication and Authorization how authentication is done ? (basic, digest, oauth2, etc.) how authorization is done ? (acl, rbac) Modules analyze configuration files of the modules (what needs to be configured in order to use a module) analyze routes (which are the routes, protection rules, which one need auth, etc.) analyze response format (content negotiation and validation, which ones are json, hal, views, etc.) analyze input field validations Custom functionalities Analyze the custom code (code that cannot be generated through Admin UI and require manual implementation) For instance: caching events services extra installed packages and libraries jobs and queues third-parties tests","title":"Discovery Phase"},{"location":"v4/transition-from-api-tools/discovery-phase/#discovery-phase-for-a-current-system-built-using-api-tools-wip","text":"In order to transition a system built using api-tools to Dotkernel API , we need to analyze the core components of it.","title":"Discovery phase for a current system built using API Tools [WIP]"},{"location":"v4/transition-from-api-tools/discovery-phase/#database","text":"there is a database in the current API ? which is the connection to database which library is used for database interaction ( laminas-db, doctrine 2, eloquent, or else )","title":"Database"},{"location":"v4/transition-from-api-tools/discovery-phase/#authentication-and-authorization","text":"how authentication is done ? (basic, digest, oauth2, etc.) how authorization is done ? (acl, rbac)","title":"Authentication and Authorization"},{"location":"v4/transition-from-api-tools/discovery-phase/#modules","text":"analyze configuration files of the modules (what needs to be configured in order to use a module) analyze routes (which are the routes, protection rules, which one need auth, etc.) analyze response format (content negotiation and validation, which ones are json, hal, views, etc.) analyze input field validations","title":"Modules"},{"location":"v4/transition-from-api-tools/discovery-phase/#custom-functionalities","text":"Analyze the custom code (code that cannot be generated through Admin UI and require manual implementation) For instance: caching events services extra installed packages and libraries jobs and queues third-parties tests","title":"Custom functionalities"},{"location":"v4/transition-from-api-tools/transition-approach/","text":"Transition approach [WIP] Dotkernel API is not a one-to-one replacement of api-tools ( former Apigility), but is only a potential solution to migrate to. Functionalities, components and architecture are different. See the Comparison between Dotkernel APi and api-tools Business cases There are at least 2 approaches for this transition: Clone 1:1 and recreate all endpoints and entities Build a new version of the current API using Dotkernel API and keep it running as separate platforms until the sunset of the current version of api-tools","title":"Transition Approach"},{"location":"v4/transition-from-api-tools/transition-approach/#transition-approach-wip","text":"Dotkernel API is not a one-to-one replacement of api-tools ( former Apigility), but is only a potential solution to migrate to. Functionalities, components and architecture are different. See the Comparison between Dotkernel APi and api-tools","title":"Transition approach [WIP]"},{"location":"v4/transition-from-api-tools/transition-approach/#business-cases","text":"There are at least 2 approaches for this transition:","title":"Business cases"},{"location":"v4/tutorials/create-book-module/","text":"Implementing a book module in DotKernel API File structure The below file structure is just an example, you can have multiple components such as event listeners, wrappers, etc. . └── src/ └── Book/ └── src/ ├── Collection/ │ └── BookCollection.php ├── Entity/ │ └── Book.php ├── Handler/ │ └── BookHandler.php ├── InputFilter/ │ ├── Input/ │ │ ├── AuthorInput.php │ │ ├── NameInput.php │ │ └── ReleaseDateInput.php │ └── BookInputFilter.php ├── Repository/ │ └── BookRepository.php ├── Service/ │ ├── BookService.php │ └── BookServiceInterface.php ├── ConfigProvider.php └── RoutesDelegator.php src/Book/src/Collection/BookCollection.php - a collection refers to a container for a group of related objects, typically used to manage sets of related entities fetched from a database src/Book/src/Entity/Book.php - an entity refers to a PHP class that represents a persistent object or data structure src/Book/src/Handler/BookHandler.php - handlers are middleware that can handle requests based on an action src/Book/src/Repository/BookRepository.php - a repository is a class responsible for querying and retrieving entities from the database src/Book/src/Service/BookService.php - is a class or component responsible for performing a specific task or providing functionality to other parts of the application src/Book/src/ConfigProvider.php - is a class that provides configuration for various aspects of the framework or application src/Book/src/RoutesDelegator.php - a routes delegator is a delegator factory responsible for configuring routing middleware based on routing configuration provided by the application src/Book/src/InputFilter/BookInputFilter.php - input filters and validators src/Book/src/InputFilter/Input/* - input filters and validator configurations File creation and contents src/Book/src/Collection/BookCollection.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Collection; use Api\\App\\Collection\\ResourceCollection; class BookCollection extends ResourceCollection { } src/Book/src/Entity/Book.php To keep things simple in this tutorial our book will have 3 properties: name , author and release date . &lt;?php declare(strict_types=1); namespace Api\\Book\\Entity; use Api\\App\\Entity\\AbstractEntity; use Api\\Book\\Repository\\BookRepository; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(\"book\")] class Book extends AbstractEntity { #[ORM\\Column(name: \"name\", type: \"string\", length: 100)] protected string $name; #[ORM\\Column(name: \"author\", type: \"string\", length: 100)] protected string $author; #[ORM\\Column(name: \"releaseDate\", type: \"datetime_immutable\")] protected DateTimeImmutable $releaseDate; public function __construct(string $name, string $author, DateTimeImmutable $releaseDate) { parent::__construct(); $this-&gt;setName($name); $this-&gt;setAuthor($author); $this-&gt;setReleaseDate($releaseDate); } public function getName(): string { return $this-&gt;name; } public function setName(string $name): self { $this-&gt;name = $name; return $this; } public function getAuthor(): string { return $this-&gt;author; } public function setAuthor(string $author): self { $this-&gt;author = $author; return $this; } public function getReleaseDate(): DateTimeImmutable { return $this-&gt;releaseDate; } public function setReleaseDate(DateTimeImmutable $releaseDate): self { $this-&gt;releaseDate = $releaseDate; return $this; } public function getArrayCopy(): array { return [ 'uuid' =&gt; $this-&gt;getUuid()-&gt;toString(), 'name' =&gt; $this-&gt;getName(), 'author' =&gt; $this-&gt;getAuthor(), 'releaseDate' =&gt; $this-&gt;getReleaseDate(), ]; } } src/Book/src/Repository/BookRepository.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Repository; use Api\\App\\Helper\\PaginationHelper; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Doctrine\\ORM\\EntityRepository; use Dot\\AnnotatedServices\\Annotation\\Entity; /** * @Entity(name=\"Api\\Book\\Entity\\Book\") * @extends EntityRepository&lt;object&gt; */ class BookRepository extends EntityRepository { public function saveBook(Book $book): Book { $this-&gt;getEntityManager()-&gt;persist($book); $this-&gt;getEntityManager()-&gt;flush(); return $book; } public function getBooks(array $filters = []): BookCollection { $page = PaginationHelper::getOffsetAndLimit($filters); $qb = $this -&gt;getEntityManager() -&gt;createQueryBuilder() -&gt;select('book') -&gt;from(Book::class, 'book') -&gt;orderBy($filters['order'] ?? 'book.created', $filters['dir'] ?? 'desc') -&gt;setFirstResult($page['offset']) -&gt;setMaxResults($page['limit']); $qb-&gt;getQuery()-&gt;useQueryCache(true); return new BookCollection($qb, false); } } src/Book/src/Service/BookService.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; use Api\\Book\\Entity\\Book; use Api\\Book\\Repository\\BookRepository; use Dot\\AnnotatedServices\\Annotation\\Inject; use DateTimeImmutable; class BookService implements BookServiceInterface { /** * @Inject({ * BookRepository::class, * }) */ public function __construct(protected BookRepository $bookRepository) { } public function createBook(array $data): Book { $book = new Book( $data['name'], $data['author'], new DateTimeImmutable($data['releaseDate']) ); return $this-&gt;bookRepository-&gt;saveBook($book); } public function getBooks(array $filters = []) { return $this-&gt;bookRepository-&gt;getBooks($filters); } } src/Book/src/Service/BookServiceInterface.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; interface BookServiceInterface { } src/Book/src/ConfigProvider.php &lt;?php declare(strict_types=1); namespace Api\\Book; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Api\\Book\\Handler\\BookHandler; use Api\\Book\\Repository\\BookRepository; use Api\\Book\\Service\\BookService; use Api\\Book\\Service\\BookServiceInterface; use Dot\\AnnotatedServices\\Factory\\AnnotatedRepositoryFactory; use Dot\\AnnotatedServices\\Factory\\AnnotatedServiceFactory; use Mezzio\\Hal\\Metadata\\MetadataMap; use Api\\App\\ConfigProvider as AppConfigProvider; class ConfigProvider { public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), MetadataMap::class =&gt; $this-&gt;getHalConfig(), ]; } public function getDependencies(): array { return [ 'factories' =&gt; [ BookHandler::class =&gt; AnnotatedServiceFactory::class, BookService::class =&gt; AnnotatedServiceFactory::class, BookRepository::class =&gt; AnnotatedRepositoryFactory::class, ], 'aliases' =&gt; [ BookServiceInterface::class =&gt; BookService::class, ], ]; } public function getHalConfig(): array { return [ AppConfigProvider::getCollection(BookCollection::class, 'books.list', 'books'), AppConfigProvider::getResource(Book::class, 'book.create'), ]; } } src/Book/src/RoutesDelegator.php &lt;?php namespace Api\\Book; use Api\\Book\\Handler\\BookHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { /** @var Application $app */ $app = $callback(); $app-&gt;get( '/books', BookHandler::class, 'books.list' ); $app-&gt;post( '/book', BookHandler::class, 'book.create' ); return $app; } } src/Book/src/InputFilter/BookInputFilter.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter; use Api\\Book\\InputFilter\\Input\\AuthorInput; use Api\\Book\\InputFilter\\Input\\NameInput; use Api\\Book\\InputFilter\\Input\\ReleaseDateInput; use Laminas\\InputFilter\\InputFilter; class BookInputFilter extends InputFilter { public function __construct() { $this-&gt;add(new NameInput('name')); $this-&gt;add(new AuthorInput('author')); $this-&gt;add(new ReleaseDateInput('releaseDate')); } } src/Book/src/InputFilter/Input/AuthorInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class AuthorInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'author'), ], true); } } src/Book/src/InputFilter/Input/NameInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class NameInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'name'), ], true); } } src/Book/src/InputFilter/Input/ReleaseDateInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\Date; use Laminas\\Validator\\NotEmpty; class ReleaseDateInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(Date::class, [ 'message' =&gt; sprintf(Message::INVALID_VALUE, 'releaseDate'), ], true); } } src/Book/src/Handler/BookHandler.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Handler; use Api\\App\\Handler\\ResponseTrait; use Api\\Book\\InputFilter\\BookInputFilter; use Api\\Book\\Service\\BookServiceInterface; use Mezzio\\Hal\\HalResponseFactory; use Mezzio\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Dot\\AnnotatedServices\\Annotation\\Inject; class BookHandler implements RequestHandlerInterface { use ResponseTrait; /** * @Inject({ * HalResponseFactory::class, * ResourceGenerator::class, * BookServiceInterface::class * }) */ public function __construct( protected HalResponseFactory $responseFactory, protected ResourceGenerator $resourceGenerator, protected BookServiceInterface $bookService ) { } public function get(ServerRequestInterface $request): ResponseInterface { $books = $this-&gt;bookService-&gt;getBooks($request-&gt;getQueryParams()); return $this-&gt;createResponse($request, $books); } public function post(ServerRequestInterface $request): ResponseInterface { $inputFilter = (new BookInputFilter())-&gt;setData($request-&gt;getParsedBody()); if (! $inputFilter-&gt;isValid()) { return $this-&gt;errorResponse($inputFilter-&gt;getMessages()); } $book = $this-&gt;bookService-&gt;createBook($inputFilter-&gt;getValues()); return $this-&gt;createResponse($request, $book); } } Configuring and registering the new module Once you set up all the files as in the example above, you will need to do a few additional configurations: register the namespace by adding this line \"Api\\\\Book\\\\\": \"src/Book/src/\", in composer.json under the autoload.psr-4 key register the module by adding Api\\Book\\ConfigProvider::class, under Api\\User\\ConfigProvider::class, register the module's routes by adding \\Api\\Book\\RoutesDelegator::class, under \\Api\\User\\RoutesDelegator::class, in src/App/src/ConfigProvider.php update Composer autoloader by running the command: composer dump-autoload It should look like this: public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, \\Api\\Admin\\RoutesDelegator::class, \\Api\\User\\RoutesDelegator::class, \\Api\\Book\\RoutesDelegator::class, ], ], 'factories' =&gt; [ ... ] ... In src/config/autoload/doctrine.global.php add this under the doctrine.driver key: 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], Api\\\\Book\\Entity' =&gt; 'BookEntities', add this under the doctrine.driver.drivers key Example: &lt;?php ... return [ 'doctrine' =&gt; [ ... 'driver' =&gt; [ 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, 'drivers' =&gt; [ 'Api\\\\App\\Entity' =&gt; 'AppEntities', 'Api\\\\Admin\\\\Entity' =&gt; 'AdminEntities', 'Api\\\\User\\\\Entity' =&gt; 'UserEntities', 'Api\\\\Book\\Entity' =&gt; 'BookEntities', ], ], 'AdminEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Admin/src/Entity', ], 'UserEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/User/src/Entity', ], 'AppEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/App/src/Entity', ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], ], ... Next we need to configure access to the newly created endpoints, add books.list and book.create to the authorization rbac array, under the UserRole::ROLE_GUEST key. Make sure you read and understand the rbac documentation. Migrations We created the Book entity, but we didn't create the associated table for it. Doctrine can handle the table creation, run the following command: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' This will check for differences between your entities and database structure and create migration files if necessary, in data/doctrine/migrations . To execute the migrations run: vendor/bin/doctrine-migrations migrate Checking endpoints If we did everything as planned we can call the http://0.0.0.0:8080/book endpoint and create a new book: curl -X POST http://0.0.0.0:8080/book -H \"Content-Type: application/json\" -d '{\"name\": \"test\", \"author\": \"author name\", \"releaseDate\": \"2023-03-03\"}' To list the books use: curl http://0.0.0.0:8080/books","title":"Creating a book module"},{"location":"v4/tutorials/create-book-module/#implementing-a-book-module-in-dotkernel-api","text":"","title":"Implementing a book module in DotKernel API"},{"location":"v4/tutorials/create-book-module/#file-structure","text":"The below file structure is just an example, you can have multiple components such as event listeners, wrappers, etc. . └── src/ └── Book/ └── src/ ├── Collection/ │ └── BookCollection.php ├── Entity/ │ └── Book.php ├── Handler/ │ └── BookHandler.php ├── InputFilter/ │ ├── Input/ │ │ ├── AuthorInput.php │ │ ├── NameInput.php │ │ └── ReleaseDateInput.php │ └── BookInputFilter.php ├── Repository/ │ └── BookRepository.php ├── Service/ │ ├── BookService.php │ └── BookServiceInterface.php ├── ConfigProvider.php └── RoutesDelegator.php src/Book/src/Collection/BookCollection.php - a collection refers to a container for a group of related objects, typically used to manage sets of related entities fetched from a database src/Book/src/Entity/Book.php - an entity refers to a PHP class that represents a persistent object or data structure src/Book/src/Handler/BookHandler.php - handlers are middleware that can handle requests based on an action src/Book/src/Repository/BookRepository.php - a repository is a class responsible for querying and retrieving entities from the database src/Book/src/Service/BookService.php - is a class or component responsible for performing a specific task or providing functionality to other parts of the application src/Book/src/ConfigProvider.php - is a class that provides configuration for various aspects of the framework or application src/Book/src/RoutesDelegator.php - a routes delegator is a delegator factory responsible for configuring routing middleware based on routing configuration provided by the application src/Book/src/InputFilter/BookInputFilter.php - input filters and validators src/Book/src/InputFilter/Input/* - input filters and validator configurations","title":"File structure"},{"location":"v4/tutorials/create-book-module/#file-creation-and-contents","text":"src/Book/src/Collection/BookCollection.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Collection; use Api\\App\\Collection\\ResourceCollection; class BookCollection extends ResourceCollection { } src/Book/src/Entity/Book.php To keep things simple in this tutorial our book will have 3 properties: name , author and release date . &lt;?php declare(strict_types=1); namespace Api\\Book\\Entity; use Api\\App\\Entity\\AbstractEntity; use Api\\Book\\Repository\\BookRepository; use DateTimeImmutable; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity(repositoryClass: BookRepository::class)] #[ORM\\Table(\"book\")] class Book extends AbstractEntity { #[ORM\\Column(name: \"name\", type: \"string\", length: 100)] protected string $name; #[ORM\\Column(name: \"author\", type: \"string\", length: 100)] protected string $author; #[ORM\\Column(name: \"releaseDate\", type: \"datetime_immutable\")] protected DateTimeImmutable $releaseDate; public function __construct(string $name, string $author, DateTimeImmutable $releaseDate) { parent::__construct(); $this-&gt;setName($name); $this-&gt;setAuthor($author); $this-&gt;setReleaseDate($releaseDate); } public function getName(): string { return $this-&gt;name; } public function setName(string $name): self { $this-&gt;name = $name; return $this; } public function getAuthor(): string { return $this-&gt;author; } public function setAuthor(string $author): self { $this-&gt;author = $author; return $this; } public function getReleaseDate(): DateTimeImmutable { return $this-&gt;releaseDate; } public function setReleaseDate(DateTimeImmutable $releaseDate): self { $this-&gt;releaseDate = $releaseDate; return $this; } public function getArrayCopy(): array { return [ 'uuid' =&gt; $this-&gt;getUuid()-&gt;toString(), 'name' =&gt; $this-&gt;getName(), 'author' =&gt; $this-&gt;getAuthor(), 'releaseDate' =&gt; $this-&gt;getReleaseDate(), ]; } } src/Book/src/Repository/BookRepository.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Repository; use Api\\App\\Helper\\PaginationHelper; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Doctrine\\ORM\\EntityRepository; use Dot\\AnnotatedServices\\Annotation\\Entity; /** * @Entity(name=\"Api\\Book\\Entity\\Book\") * @extends EntityRepository&lt;object&gt; */ class BookRepository extends EntityRepository { public function saveBook(Book $book): Book { $this-&gt;getEntityManager()-&gt;persist($book); $this-&gt;getEntityManager()-&gt;flush(); return $book; } public function getBooks(array $filters = []): BookCollection { $page = PaginationHelper::getOffsetAndLimit($filters); $qb = $this -&gt;getEntityManager() -&gt;createQueryBuilder() -&gt;select('book') -&gt;from(Book::class, 'book') -&gt;orderBy($filters['order'] ?? 'book.created', $filters['dir'] ?? 'desc') -&gt;setFirstResult($page['offset']) -&gt;setMaxResults($page['limit']); $qb-&gt;getQuery()-&gt;useQueryCache(true); return new BookCollection($qb, false); } } src/Book/src/Service/BookService.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; use Api\\Book\\Entity\\Book; use Api\\Book\\Repository\\BookRepository; use Dot\\AnnotatedServices\\Annotation\\Inject; use DateTimeImmutable; class BookService implements BookServiceInterface { /** * @Inject({ * BookRepository::class, * }) */ public function __construct(protected BookRepository $bookRepository) { } public function createBook(array $data): Book { $book = new Book( $data['name'], $data['author'], new DateTimeImmutable($data['releaseDate']) ); return $this-&gt;bookRepository-&gt;saveBook($book); } public function getBooks(array $filters = []) { return $this-&gt;bookRepository-&gt;getBooks($filters); } } src/Book/src/Service/BookServiceInterface.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Service; interface BookServiceInterface { } src/Book/src/ConfigProvider.php &lt;?php declare(strict_types=1); namespace Api\\Book; use Api\\Book\\Collection\\BookCollection; use Api\\Book\\Entity\\Book; use Api\\Book\\Handler\\BookHandler; use Api\\Book\\Repository\\BookRepository; use Api\\Book\\Service\\BookService; use Api\\Book\\Service\\BookServiceInterface; use Dot\\AnnotatedServices\\Factory\\AnnotatedRepositoryFactory; use Dot\\AnnotatedServices\\Factory\\AnnotatedServiceFactory; use Mezzio\\Hal\\Metadata\\MetadataMap; use Api\\App\\ConfigProvider as AppConfigProvider; class ConfigProvider { public function __invoke(): array { return [ 'dependencies' =&gt; $this-&gt;getDependencies(), MetadataMap::class =&gt; $this-&gt;getHalConfig(), ]; } public function getDependencies(): array { return [ 'factories' =&gt; [ BookHandler::class =&gt; AnnotatedServiceFactory::class, BookService::class =&gt; AnnotatedServiceFactory::class, BookRepository::class =&gt; AnnotatedRepositoryFactory::class, ], 'aliases' =&gt; [ BookServiceInterface::class =&gt; BookService::class, ], ]; } public function getHalConfig(): array { return [ AppConfigProvider::getCollection(BookCollection::class, 'books.list', 'books'), AppConfigProvider::getResource(Book::class, 'book.create'), ]; } } src/Book/src/RoutesDelegator.php &lt;?php namespace Api\\Book; use Api\\Book\\Handler\\BookHandler; use Mezzio\\Application; use Psr\\Container\\ContainerInterface; class RoutesDelegator { public function __invoke(ContainerInterface $container, string $serviceName, callable $callback): Application { /** @var Application $app */ $app = $callback(); $app-&gt;get( '/books', BookHandler::class, 'books.list' ); $app-&gt;post( '/book', BookHandler::class, 'book.create' ); return $app; } } src/Book/src/InputFilter/BookInputFilter.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter; use Api\\Book\\InputFilter\\Input\\AuthorInput; use Api\\Book\\InputFilter\\Input\\NameInput; use Api\\Book\\InputFilter\\Input\\ReleaseDateInput; use Laminas\\InputFilter\\InputFilter; class BookInputFilter extends InputFilter { public function __construct() { $this-&gt;add(new NameInput('name')); $this-&gt;add(new AuthorInput('author')); $this-&gt;add(new ReleaseDateInput('releaseDate')); } } src/Book/src/InputFilter/Input/AuthorInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class AuthorInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'author'), ], true); } } src/Book/src/InputFilter/Input/NameInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\NotEmpty; class NameInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(NotEmpty::class, [ 'message' =&gt; sprintf(Message::VALIDATOR_REQUIRED_FIELD_BY_NAME, 'name'), ], true); } } src/Book/src/InputFilter/Input/ReleaseDateInput.php &lt;?php declare(strict_types=1); namespace Api\\Book\\InputFilter\\Input; use Api\\App\\Message; use Laminas\\Filter\\StringTrim; use Laminas\\Filter\\StripTags; use Laminas\\InputFilter\\Input; use Laminas\\Validator\\Date; use Laminas\\Validator\\NotEmpty; class ReleaseDateInput extends Input { public function __construct(?string $name = null, bool $isRequired = true) { parent::__construct($name); $this-&gt;setRequired($isRequired); $this-&gt;getFilterChain() -&gt;attachByName(StringTrim::class) -&gt;attachByName(StripTags::class); $this-&gt;getValidatorChain() -&gt;attachByName(Date::class, [ 'message' =&gt; sprintf(Message::INVALID_VALUE, 'releaseDate'), ], true); } } src/Book/src/Handler/BookHandler.php &lt;?php declare(strict_types=1); namespace Api\\Book\\Handler; use Api\\App\\Handler\\ResponseTrait; use Api\\Book\\InputFilter\\BookInputFilter; use Api\\Book\\Service\\BookServiceInterface; use Mezzio\\Hal\\HalResponseFactory; use Mezzio\\Hal\\ResourceGenerator; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Dot\\AnnotatedServices\\Annotation\\Inject; class BookHandler implements RequestHandlerInterface { use ResponseTrait; /** * @Inject({ * HalResponseFactory::class, * ResourceGenerator::class, * BookServiceInterface::class * }) */ public function __construct( protected HalResponseFactory $responseFactory, protected ResourceGenerator $resourceGenerator, protected BookServiceInterface $bookService ) { } public function get(ServerRequestInterface $request): ResponseInterface { $books = $this-&gt;bookService-&gt;getBooks($request-&gt;getQueryParams()); return $this-&gt;createResponse($request, $books); } public function post(ServerRequestInterface $request): ResponseInterface { $inputFilter = (new BookInputFilter())-&gt;setData($request-&gt;getParsedBody()); if (! $inputFilter-&gt;isValid()) { return $this-&gt;errorResponse($inputFilter-&gt;getMessages()); } $book = $this-&gt;bookService-&gt;createBook($inputFilter-&gt;getValues()); return $this-&gt;createResponse($request, $book); } }","title":"File creation and contents"},{"location":"v4/tutorials/create-book-module/#configuring-and-registering-the-new-module","text":"Once you set up all the files as in the example above, you will need to do a few additional configurations: register the namespace by adding this line \"Api\\\\Book\\\\\": \"src/Book/src/\", in composer.json under the autoload.psr-4 key register the module by adding Api\\Book\\ConfigProvider::class, under Api\\User\\ConfigProvider::class, register the module's routes by adding \\Api\\Book\\RoutesDelegator::class, under \\Api\\User\\RoutesDelegator::class, in src/App/src/ConfigProvider.php update Composer autoloader by running the command: composer dump-autoload It should look like this: public function getDependencies(): array { return [ 'delegators' =&gt; [ Application::class =&gt; [ RoutesDelegator::class, \\Api\\Admin\\RoutesDelegator::class, \\Api\\User\\RoutesDelegator::class, \\Api\\Book\\RoutesDelegator::class, ], ], 'factories' =&gt; [ ... ] ... In src/config/autoload/doctrine.global.php add this under the doctrine.driver key: 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], Api\\\\Book\\Entity' =&gt; 'BookEntities', add this under the doctrine.driver.drivers key Example: &lt;?php ... return [ 'doctrine' =&gt; [ ... 'driver' =&gt; [ 'orm_default' =&gt; [ 'class' =&gt; MappingDriverChain::class, 'drivers' =&gt; [ 'Api\\\\App\\Entity' =&gt; 'AppEntities', 'Api\\\\Admin\\\\Entity' =&gt; 'AdminEntities', 'Api\\\\User\\\\Entity' =&gt; 'UserEntities', 'Api\\\\Book\\Entity' =&gt; 'BookEntities', ], ], 'AdminEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Admin/src/Entity', ], 'UserEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/User/src/Entity', ], 'AppEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/App/src/Entity', ], 'BookEntities' =&gt; [ 'class' =&gt; AttributeDriver::class, 'cache' =&gt; 'array', 'paths' =&gt; __DIR__ . '/../../src/Book/src/Entity', ], ], ... Next we need to configure access to the newly created endpoints, add books.list and book.create to the authorization rbac array, under the UserRole::ROLE_GUEST key. Make sure you read and understand the rbac documentation.","title":"Configuring and registering the new module"},{"location":"v4/tutorials/create-book-module/#migrations","text":"We created the Book entity, but we didn't create the associated table for it. Doctrine can handle the table creation, run the following command: vendor/bin/doctrine-migrations diff --filter-expression='/^(?!oauth_)/' This will check for differences between your entities and database structure and create migration files if necessary, in data/doctrine/migrations . To execute the migrations run: vendor/bin/doctrine-migrations migrate","title":"Migrations"},{"location":"v4/tutorials/create-book-module/#checking-endpoints","text":"If we did everything as planned we can call the http://0.0.0.0:8080/book endpoint and create a new book: curl -X POST http://0.0.0.0:8080/book -H \"Content-Type: application/json\" -d '{\"name\": \"test\", \"author\": \"author name\", \"releaseDate\": \"2023-03-03\"}' To list the books use: curl http://0.0.0.0:8080/books","title":"Checking endpoints"}]}